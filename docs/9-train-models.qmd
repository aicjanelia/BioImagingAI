---
author: 
  - name: Joanna Pylvänäinen 
    orcid: 0000-0002-3540-5150
    affiliations:
      - name: Turku Bioscience Centre, University of Turku and Åbo Akademi University, FI-20520 Turku, FI
        country: Finland
      - name: Faculty of Science and Engineering, Cell Biology, Åbo Akademi University, FI-20520 Turku, FI
        country: Finland
      - name: InFLAMES Research Flagship Center, University of Turku, FI- 20520, Turku, FI
        country: Finland
  - name: Iván Hidalgo-Cenalmor
    orcid: 0009-0000-8923-568X
    affiliations:
      - name: Turku Bioscience Centre, University of Turku and Åbo Akademi University, FI-20520 Turku, FI
        country: Finland
      - name: Faculty of Science and Engineering, Cell Biology, Åbo Akademi University, FI-20520 Turku, FI
        country: Finland
      - name: InFLAMES Research Flagship Center, University of Turku, FI- 20520, Turku, FI
        country: Finland
  - name: Guillaume Jacquemet
    orcid: 0000-0002-9286-920X
    affiliations:
      - name: Turku Bioscience Centre, University of Turku and Åbo Akademi University, FI-20520 Turku, FI
        country: Finland
      - name: Faculty of Science and Engineering, Cell Biology, Åbo Akademi University, FI-20520 Turku, FI
        country: Finland
      - name: InFLAMES Research Flagship Center, University of Turku, FI- 20520, Turku, FI
        country: Finland
      - name: Turku Bioimaging, University of Turku and Åbo Akademi University, FI- 20520 Turku, FI
        country: Finland

subtitle: Practical considerations to train and use deep learning models in microscopy
---
# Chapter 9: How to Train and Use Deep Learning Models in Microscopy

# **Table of contents** {#table-of-contents}

[**Table of contents	1**](#table-of-contents)

[**1\. Introduction	2**](#introduction)

[1.1. The challenge	2](#the-challenge)

[1.2. The different types of segmentation	3](#the-different-types-of-segmentation)

[**2\. Preparing for your segmentation project	4**](#preparing-for-your-segmentation-project)

[2.1. Defining your segmentation task and success criteria	4](#defining-your-segmentation-task-and-success-criteria)

[2.2. Evaluating alternatives: Is DL the right choice?	4](#evaluating-alternatives:-is-dl-the-right-choice?)

[**3\. Implementing a DL segmentation workflow	5**](#implementing-a-dl-segmentation-workflow)

[3.1. Overview of a typical DL segmentation workflow	5](#overview-of-a-typical-dl-segmentation-workflow)

[3.2. Selecting a suitable DL approach	6](#selecting-a-suitable-dl-approach)

[3.3. Deciding whether to train a new model	7](#deciding-whether-to-train-a-new-model)

[3.3.1. Leveraging pre-trained models	7](#leveraging-pre-trained-models)

[3.3.2. When to train your model	8](#when-to-train-your-model)

[3.4. Preparing your dataset for training	8](#preparing-your-dataset-for-training)

[3.4.1. Types of model training	8](#types-of-model-training)

[3.4.2. Creating Manual Annotations	9](#creating-manual-annotations)

[3.4.3. Accelerating annotation with pre-trained models	9](#accelerating-annotation-with-pre-trained-models)

[3.4.4. Expanding your dataset with augmentation and synthetic data	10](#expanding-your-dataset-with-augmentation-and-synthetic-data)

[3.4.5. Choosing the dataset size: specific vs. general models	10](#choosing-the-dataset-size:-specific-vs.-general-models)

[3.5. Training a segmentation model from scratch	10](#training-a-segmentation-model-from-scratch)

[3.5.1. Splitting your training data: training, validation, and test sets	10](#splitting-your-training-data:-training,-validation,-and-test-sets)

[3.5.2. Understanding the training process	11](#understanding-the-training-process)

[3.5.3. Choosing your model hyperparameters	12](#choosing-your-model-hyperparameters)

[3.5.4. Monitoring training and validation Losses	13](#monitoring-training-and-validation-losses)

[3.6. Fine-Tuning Pre-existing Models	14](#fine-tuning-pre-existing-models)

[3.6.1. Applying Transfer Learning	14](#applying-transfer-learning)

[3.6.2. Conducting fine-tuning	14](#conducting-fine-tuning)

[3.6.3. Iterative training: keeping humans in the loop	15](#iterative-training:-keeping-humans-in-the-loop)

[3.7. Evaluating the performance of your model	17](#evaluating-the-performance-of-your-model)

[3.8. Deploying your model on new data	18](#deploying-your-model-on-new-data)

[3.9. Troubleshooting Common Problems	19](#troubleshooting-common-problems)

[**4\. Further considerations for DL segmentation	21**](#further-considerations-for-dl-segmentation)

[**4.1. Choosing the Right Tools for DL	21**](#choosing-the-right-tools-for-dl)

[**4.2. Managing Computational Resources	22**](#managing-computational-resources)

[4.3. Ensuring Reproducibility in DL	23](#ensuring-reproducibility-in-dl)

[**5\. Summary & Outlook	24**](#summary-&-outlook)

[**6\. References	25**](#references)

# 1. Introduction {#introduction}

  ##  1.1 The challenge {#the-challenge}

The growing volume and complexity of image data necessitate increasingly advanced analytical tools. One example of challenging tasks is image segmentation, the process of identifying and delineating structures of interest within images. Segmentation can be particularly difficult and time-consuming when dealing with large, multidimensional datasets, such as 3D volumes or time-lapse sequences, where manual annotation becomes impractical. Machine learning (ML), especially deep learning (DL), can provide effective solutions to these challenges [(Heinrich et al., 2021\)](https://www.zotero.org/google-docs/?wUQFtp).

ML algorithms learn patterns from data to perform tasks such as image classification and segmentation. Traditional ML methods, like random forest classifiers, depend on manually defined image features to classify pixels [(Arganda-Carreras et al., 2017; Arzt et al., 2022; Berg et al., 2019\)](https://www.zotero.org/google-docs/?8oDvYR). In contrast, DL algorithms can automatically discover and extract relevant features directly from image data using multilayer neural networks, which eliminates the need for manual feature selection. DL techniques are widely applied in complex image analysis tasks, including segmentation, object detection, feature extraction, denoising, and restoration [(Moen et al., 2019; Pylvänäinen et al., 2023\)](https://www.zotero.org/google-docs/?YM0SxJ). Due to their ability to automatically learn hierarchical features, DL methods usually achieve greater accuracy and efficiency than traditional ML techniques [(Krizhevsky et al., 2012; Ronneberger et al., 2015\)](https://www.zotero.org/google-docs/?b2WkBe).

Segmentation greatly benefits from machine learning and DL, as manual segmentation is extremely time-consuming and impractical for large datasets. This chapter offers practical guidance on preparing a segmentation project and emphasises effective DL applications to tackle these challenges.

## 1.2 The different types of segmentation {#the-different-types-of-segmentation}

Before discussing how to segment microscopy images using deep learning, it is important to describe the different types of segmentation you may want to achieve. Segmentation tasks in microscopy can be categorised into three main types (**Figure 1**): 

**Binary** **segmentation:** This is the simplest form of segmentation that separates the foreground from the background. For example, in a microscopy image, this involves distinguishing cell nuclei (foreground) from the rest of the image (background). This method is useful for detecting whether a structure is present or absent without distinguishing individual objects.

**Instance** **segmentation:** This type of segmentation identifies and labels each object independently. For instance, each cell in an image obtains a unique label. This method is crucial for tracking individual cells over time or measuring specific characteristics of each cell separately.

**Semantic** **segmentation:** This segmentation strategy involves labelling every pixel in an image according to its class, such as "nucleus," "cytoplasm," or "background." Unlike instance segmentation, semantic segmentation does not differentiate between individual objects within the same class. This method is beneficial for analysing the spatial relationships and distribution of various cellular components.

![Figure 1](docs/9-figures/chapter9_1_segmentation_types.png)

**Figure 1: The three main types of segmentation in microscopy images**. Original Image: A raw grayscale fluorescence microscopy image showing cell nuclei stained with a nuclear marker. Binary Segmentation: Simplifies the image into two classes—foreground (white, nuclei) and background (black). Instance Segmentation: Assigns a unique label (shown in different colours) to each nucleus, facilitating individual object identification. Semantic Segmentation: Categorises each pixel into predefined classes—nucleus (purple), nucleus edge (yellow), and background (teal)—without distinguishing between individual objects. 

# 2. Preparing for your segmentation project {#preparing-for-your-segmentation-project}

   ## 2.1. Defining your segmentation task and success criteria {#defining-your-segmentation-task-and-success-criteria}

Every image analysis project should start by clearly defining the scientific question you wish to answer and your success criteria. Careful planning of your objectives ensures that the chosen segmentation approach closely aligns with your scientific goals and will guide critical decisions about data annotation, model selection and performance evaluation. 

Consider whether your segmentation solution is meant for a specific experiment or needs to generalise across various imaging techniques, sample types, or experimental conditions. Additionally, evaluate the volume of data to analyse, the feasibility of manual analysis, and the resources available to create a tailored image analysis pipeline. Avoid overengineering a solution when a simple analysis could provide the answer you seek.

Additionally, clearly define the success criteria based on your objectives. For example, be prepared to answer the question, “What do I need to accomplish for my analysis to be sufficient?” This is important because no analysis is ever 100% accurate. Establishing these criteria early streamlines both the development and evaluation processes, ensuring that your outcomes are scientifically meaningful and practically useful.

## 2.2 Evaluating alternatives: Is DL the right choice? {#evaluating-alternatives:-is-dl-the-right-choice?}

![Figure 2](docs/9-figures/chapter9_2_yes or no DL.png)

**Figure 2: Is DL the right choice for your segmentation project?** This decision tree guides the selection of appropriate segmentation approaches based on data complexity and project needs. Begin by testing classical image processing methods, such as intensity-based thresholding, which are efficient and easy to apply for well-defined features. If these methods prove insufficient, consider using a pixel classifier, which provides a user-friendly and effective solution for smaller datasets. Only consider deep learning if you possess a large annotated dataset and previous methods have failed. In the absence of suitable data or methods, manual annotation may be necessary.

Choosing the right computational method is essential for consistent and reproducible image analysis. While deep learning (DL) can deliver exceptional segmentation performance, traditional methods and pixel classifiers still offer straightforward and efficient solutions for most tasks (**Figure 2**). 

Traditional image processing techniques—such as intensity-based thresholding, morphological operations, edge detection, and filtering—are ideal for objects with clear, distinguishable features. These methods are well-documented, easy to understand, and usually require minimal computing resources. Pixel classifiers, in particular, are user-friendly and can efficiently tackle many segmentation challenges with minimal manual annotation, making them highly effective for simpler analyses or smaller datasets.

DL methods excel in complex scenarios where traditional approaches fail, especially when dealing with noisy or context-dependent data. When trained on large, annotated datasets, DL models can effectively generalise across diverse imaging conditions and sample types, rapidly processing significant volumes of images. However, in the absence of pre-trained models, DL methods rarely offer shortcuts for data analysis. DL methods generally take effort and time to implement.

If you are unsure which approach to use, we usually recommend first trying classical image processing methods and pixel classifiers (**Figure 1**). We typically initiate a DL project only if these methods fail to produce satisfactory results (see [Section 3.3.2](#when-to-train-your-model)).

# 3. Implementing a DL segmentation workflow {#implementing-a-dl-segmentation-workflow}

   ## 3.1  Overview of a typical DL segmentation workflow {#overview-of-a-typical-dl-segmentation-workflow}

Once you decide to implement a DL approach for segmentation, the workflow can be divided into a series of steps (**Figure 3**).

The process starts by clearly defining your segmentation task and selecting the right DL approach (Step 1). Next, evaluate whether any existing pre-trained models can be used directly on your data or adapted (Step 2). If additional training is required—either from scratch or through transfer learning—prepare an appropriate training dataset that reflects your segmentation problem (Step 3). Then, train your model using the prepared dataset (Step 4\) and thoroughly evaluate its performance using validation or test data (Step 5). Based on the results, you may need to refine the model by adjusting hyperparameters, improving annotations, or expanding the dataset. Once the model performs satisfactorily, it can be used to segment new, unseen data (Step 6).

![Figure 3](docs/9-figures/chapter9_3_steps for training.png)

**Figure 3: Conceptual workflow for training a DL segmentation model.** The workflow begins with defining the segmentation task (Step 1), followed by searching for suitable pre-trained models (Step 2). If no such model exists, a training dataset must be prepared (Step 3), and the model is trained (Step 4). The trained model is then evaluated on validation or test data (Step 5). If it performs well, it can be applied to new data (Step 6); otherwise, the model is iteratively refined by returning to earlier steps. Feedback loops from evaluation to earlier stages help refine and improve the model accuracy.

##  3.2 Selecting a suitable DL approach {#selecting-a-suitable-dl-approach}

The first step in choosing a DL approach for image segmentation is to clearly define your segmentation task, whether it’s binary, semantic, or instance segmentation (**Figure** **1**), and to determine if you require 2D or 3D segmentation. Next, you should consider whether the model or tool you plan to use makes assumptions about the shapes or structures of the objects you want to segment. Understanding these assumptions will aid in selecting a model that fits your specific biological problem (see [Section 2.1](#defining-your-segmentation-task-and-success-criteria)). Additionally, consider the amount of data that needs annotation for a particular DL approach (see [Section  3.4.5](#choosing-the-dataset-size:-specific-vs.-general-models)). Finally, take into account your available computational resources (see [Section 4.2](#managing-computational-resources)). More complex models typically demand more GPU memory, longer training times, and additional storage, especially for 3D data or large datasets.

For example, StarDist [(Schmidt et al., 2018\)](https://www.zotero.org/google-docs/?VbEAR3), a widely used tool for nuclei segmentation, assumes that objects are star-convex polygons. This assumption works well for round or oval shapes but makes StarDist less suitable for segmenting irregularly shaped or elongated structures. In contrast, Cellpose [(Stringer et al., 2021\)](https://www.zotero.org/google-docs/?lODjDF) uses spatial vector flows to direct pixels toward object centres. This approach enables Cellpose to segment objects of various shapes and sizes, including irregular, elongated, or non-convex forms. 

Choosing the right DL strategy requires aligning your objective, object shape, data dimensionality, and computing capacity with the strengths and assumptions of the available DL architectures.

## 3.3 Deciding whether to train a new model {#deciding-whether-to-train-a-new-model}

![Figure 4](docs/9-figures/chapter9_4_training approach.png)

**Figure 4: Decision workflow for selecting a deep learning model training approach.** This flowchart outlines how to determine an appropriate training approach based on the availability and performance of pre-trained models. 

### 3.3.1 Leveraging pre-trained models {#leveraging-pre-trained-models}

The increasing availability of already trained (pre-trained) DL models has greatly simplified image analysis. Many of these models can be directly applied to your data, removing the need to train a model yourself [(Bejarano et al., 2024; Fisch et al., 2024\)](https://www.zotero.org/google-docs/?ZvLOBv). This reduces the technical barrier and saves time, making advanced analysis more accessible. However, it is essential to evaluate the quality of any pre-trained model before relying on its results (**Figure 4\)**. A model that performs well in one context may not be as effective on your specific data. Always conduct quality control by visually inspecting the outputs and assessing performance with quantitative metrics such as Intersection over Union (IoU) or F1-score, using a small, representative test set. This step is vital when model predictions are used in downstream analyses (see [Section 3.7](#evaluating-the-performance-of-your-model)).

Another significant benefit of pre-trained models is their adaptability. Instead of starting from scratch, you can often fine-tune an existing model (see [Section 3.6](#fine-tuning-pre-existing-models)). This method entails retraining the model with a smaller, task-specific dataset, enabling it to adjust to your images while requiring far fewer annotations.

Several excellent resources host pre-trained models suitable for microscopy:

* BioImage Model Zoo [(Ouyang et al., 2022\)](https://www.zotero.org/google-docs/?Z0EtfJ) is an open-source platform that provides models for various tasks. The models include metadata and are compatible with tools such as ZeroCostDL4Mic, BiaPy, DeepImageJ, and ilastik.  
* DeepCell [(Bannon et al., 2021\)](https://www.zotero.org/google-docs/?i6kB6y) offers scalable models for nuclear, membrane, and cytoplasmic segmentation, with deployment options available in the cloud or locally through Docker.  
* The MONAI Model Zoo [(Cardoso et al., 2022\)](https://www.zotero.org/google-docs/?KtmHHz) focuses on medical imaging, such as MRI and CT, while offering modular PyTorch-based models that can often be adapted for microscopy tasks.  
* General-purpose model hubs such as PyTorch Hub, TensorFlow Hub, and Hugging Face Model Hub host various models. Although they are not specific to microscopy, many models can be fine-tuned for segmentation using annotated datasets.

DL segmentation tools such as StarDist or CellPose also include their own collection of pre-trained models [(Pachitariu and Stringer, 2022\)](https://www.zotero.org/google-docs/?AO5PVU). Researchers also increasingly share trained models alongside their datasets and publications, promoting open science. Platforms like Zenodo are commonly used for this purpose [(Fazeli et al., 2020; Follain et al., 2024\)](https://www.zotero.org/google-docs/?dOhtAh), although deployment may require handling specific file formats or environments.

### 3.3.2 When to train your model {#when-to-train-your-model}

Pre-trained models serve as an excellent starting point for various microscopy tasks. However, there are many scenarios where training a custom model becomes essential. Custom training enables the model to learn the specific characteristics of your dataset, experiment, or imaging modality, resulting in enhanced performance [(Archit et al., 2025; Pachitariu and Stringer, 2022; von Chamier et al., 2021\)](https://www.zotero.org/google-docs/?0rCc29). This is particularly crucial when your data differs significantly from the data used to train existing models. Thus, their performance should always be validated. If quality assessment metrics are poor or key features are not accurately segmented, consider training your model.

Ultimately, always evaluate the model’s performance against your defined success criteria (see [Section 3.7](#evaluating-the-performance-of-your-model)). Custom training may be the best path forward if the current model does not meet your needs.

## 3.4 Preparing your dataset for training {#preparing-your-dataset-for-training}

A well-designed training dataset is essential for developing a successful segmentation model. The number of images and the quality of annotations needed vary based on factors such as task complexity and the architecture of the intended model. 

### 3.4.1 Types of model training {#types-of-model-training}

Most segmentation models are trained using supervised learning, where each input image is paired with a manually annotated ground truth mask. In this context, all objects that need segmentation must be annotated in the training dataset. This approach enables the model to learn a direct mapping from raw images to segmentation outputs (**Figure 7**).

However, alternative approaches can help reduce the need for extensive manual annotations:

* **Unsupervised learning** trains models without paired input and output data. Instead, the network identifies patterns or similarities in unlabelled images [(Kochetov et al., 2024\)](https://www.zotero.org/google-docs/?sGDRMX).  
* **Self-supervised learning** involves designing tasks in which the model learns useful features directly from the input data without needing explicit labels [(Liu et al., 2025\)](https://www.zotero.org/google-docs/?Hfkis6).  
* **Weakly supervised learning** uses partial, noisy, or imprecise labels to guide training, which can significantly reduce annotation effort [(Caicedo et al., 2018; Moshkov et al., 2024\)](https://www.zotero.org/google-docs/?xOWTQk).

 ### 3.4.2 Creating Manual Annotations {#creating-manual-annotations}

Creating accurate annotations manually is time-consuming, particularly for 3D datasets. Tools like Fiji [(Schindelin et al., 2012\)](https://www.zotero.org/google-docs/?YaGIAO), Napari [(Ahlers et al., 2023\)](https://www.zotero.org/google-docs/?NHVSEB), and QuPath [(Bankhead et al., 2017\)](https://www.zotero.org/google-docs/?p4mMK5) are frequently employed for manual labelling. Typically, manual annotation involves drawing each object on the image and converting it into a mask or label. 

Here is an example pipeline for manually annotating data using Fiji [(Fazeli et al., 2020\)](https://www.zotero.org/google-docs/?8iYHEL). 

* Open Fiji – activate the LOCI update site and restart Fiji. 

* Open your image to annotate. 

* Select the Oval or Freehand selection tool. 

* Start drawing around each object (yes, each one\!). 

* After drawing each object, press “t” on your keyboard → the selection will be stored in the ROI manager. 

* Repeat until all objects are in the ROI manager. 

* When finished, go to Plugins › LOCI › ROI Map. 

* Save the generated ROI map with the same title as the original image in a separate folder. 

* At the end, you will have one folder with the original images and another for the ROI maps.

 ### 3.4.3 Accelerating annotation with pre-trained models {#accelerating-annotation-with-pre-trained-models}

Creating high-quality annotations often represents the most time-consuming aspect of training a DL model for segmentation. To alleviate this burden, pre-trained DL models such as those provided with StarDist [(Schmidt et al., 2018\)](https://www.zotero.org/google-docs/?1AEwI2) and Cellpose [(Stringer et al., 2021\)](https://www.zotero.org/google-docs/?8GrKdA) can generate initial segmentations that users can manually refine. These annotations can be reintegrated into the model for retraining, establishing an iterative cycle that accelerates both labelling and model refinement. 

New tools are also pushing the boundaries of interactive annotation. For example, Segment Anything for Microscopy (μSAM) [(Archit et al., 2025\)](https://www.zotero.org/google-docs/?Y5qh31) facilitates automatic and user-guided segmentation and allows the model to be retrained on user-provided data. Similarly, Cellpose 2.0 [(Pachitariu and Stringer, 2022\)](https://www.zotero.org/google-docs/?Prl7Hs) features a human-in-the-loop workflow, allowing users to edit DL-generated segmentations. This hybrid approach enhances accuracy while significantly reducing the time and effort required for manual annotation.

 ### 3.4.4 Expanding your dataset with augmentation and synthetic data {#expanding-your-dataset-with-augmentation-and-synthetic-data}

When the number of training samples is limited, augmentation techniques can enhance dataset diversity to improve the model's generalisation ability and performance on validation and testing [(Lecun et al., 1998; Shorten and Khoshgoftaar, 2019\)](https://www.zotero.org/google-docs/?lnvXBi). Common augmentation strategies include image rotation, flipping, scaling, and contrast adjustment. 

In the absence of sufficient real data, synthetic data generated through simulations or domain randomisation can help pre-train or bootstrap a model [(Lin et al., 2022; Rangel DaCosta et al., 2024\)](https://www.zotero.org/google-docs/?tycKDC). These synthetic samples can expose the model to a broader range of scenarios early in training before transitioning to fine-tuning with real, annotated data.

In summary, a successful segmentation pipeline relies on a careful balance between data quantity and annotation quality. Augmentation strategies can efficiently help to scale and balance training datasets.

 ### 3.4.5 Choosing the dataset size: specific vs. general models {#choosing-the-dataset-size:-specific-vs.-general-models}

In supervised training, it is crucial that each image in the training set is accompanied by a corresponding label image (see [Section 3.4.1](#types-of-model-training)). The number of image-label pairs required depends on the number of labels per image, the complexity of the model and the desired level of generalizability. Still, the key is having enough representative examples and corresponding annotations for the model to learn meaningful patterns. 

Small and well-curated datasets consisting of tens of images may suffice for highly specific applications, such as segmenting cells or nuclei using a defined imaging modality [(von Chamier et al., 2021\)](https://www.zotero.org/google-docs/?JbHF9k). In these scenarios, transfer learning can also be especially beneficial (see [Section 3.6](#fine-tuning-pre-existing-models)). Models designed to generalise across a wide range of conditions, tissue types, or imaging modalities typically require much larger and more diverse datasets (hundreds to thousands of annotated images) [(Stringer et al., 2021\)](https://www.zotero.org/google-docs/?JyXuWL). These datasets are essential for capturing the inherent variability in broader use cases. 

## 3.5 Training a segmentation model from scratch {#training-a-segmentation-model-from-scratch}

Once you have annotated your training dataset to train your segmentation model, the next steps are to organise your data for training, initialise your model by selecting appropriate hyperparameters, and start the training process (**Figure 7**).

### 3.5.1 Splitting your training data: training, validation, and test sets {#splitting-your-training-data:-training,-validation,-and-test-sets}

A crucial part of preparing your dataset is dividing it into three subsets: training, validation, and test sets. Each subset should contain the original microscopy images paired with their corresponding ground truth segmentations. A common strategy is to allocate 70–80% of the data for training, 10–15% for validation, and the remainder for testing. To ensure unbiased evaluation, ensure these subsets do not overlap in terms of fields of view and represent the variability of your entire dataset.

The **training set** is used to train the model to recognise relevant features. To enhance generalisation, it must encompass a broad spectrum of scenarios and image conditions. Otherwise, the model risks overfitting—excelling with the training data but faltering with new images (**Figure 6**).

The **validation set** is used during training to provide feedback on the model's performance with unseen data. This feedback, conveyed as validation loss, assists in detecting overfitting (**Figure 6**), guiding hyperparameter tuning (see [Section 3.5.3](#choosing-your-model-hyperparameters)), and informing training decisions. Although a separate validation set is ideal, many workflows create one in practice by reserving a portion (typically 10% to 30%) of the training data.

The **test set** serves a separate role: it evaluates the model's performance on entirely unseen data. Unlike the validation set, the test set is not utilised during training, ensuring an unbiased performance assessment. Test images should also include ground truth annotations to facilitate quantitative quality control. Reporting test set performance, using metrics such as accuracy, IoU, or F1-score, is crucial, especially when publishing or benchmarking your model [(Laine et al., 2021\)](https://www.zotero.org/google-docs/?J6lJo7).

### 3.5.2 Understanding the training process {#understanding-the-training-process}

A DL model is composed of multiple layers (**Figure 5**). Each layer contains tens to hundreds of image processing operations (typically multiplications or convolutions), each controlled by multiple adjustable parameters (called weights). Altogether, a DL model may contain millions of adjustable weights. When an input image is processed by a DL model, it is sequentially processed by each layer until an output is generated. Segmentation tasks typically involve converting input images into labelled outputs. During training, the model weights are modified as the model learns how to perform a specific task.

![Figure 5](docs/9-figures/chapter9_5_UNET_architecture.png)

**Figure 5: 2D U-Net architecture for image segmentation.** It applies layers of convolutions, pooling, and upsampling to extract features and generate labelled segmentation masks. During training, model weights are iteratively adjusted based on the difference between predictions and ground truth labels, using a loss function and backpropagation. 

Training begins with initialising these weights. When training from scratch, the initialisation is often random. However, when using a pre-trained model, the weights are already optimized based on previous training, providing the model with a significant head start (see Section 3.6).

The training process is iterative (**Figure 7**). Each cycle of training is called an epoch. During each epoch, the model typically learns from every image in the training set. Since datasets are often too large to fit into memory all at once, each epoch is divided into steps or iterations, with each step processing a smaller subset of the data known as a batch. The batch size determines how many samples are processed simultaneously.

During each step, the model generates predictions for the current data batch. These predictions are compared to the ground truth labels using a loss function that calculates the similarity between the predictions and the ground truths. This score is called the training loss. The model utilises this feedback to adjust its weights through a process known as backpropagation, guided by an optimisation algorithm, to improve its accuracy in future iterations.

At the end of each epoch, the model assesses its performance on the validation set, which comprises data it has not encountered during training. This produces the validation loss, indicating how well the model generalises to new data.

Monitoring both training and validation losses during training helps determine whether the model is learning effectively. A consistently decreasing validation loss indicates that the model is improving and generalising well (see [Section 3.5.4](#monitoring-training-and-validation-losses)).

### 3.5.3 Choosing your model hyperparameters {#choosing-your-model-hyperparameters}

Now that you understand the training process, the next step is to configure the model's hyperparameters, which are the settings that dictate how the model learns. While the model’s parameters (its weights) are updated during training, hyperparameters are established beforehand, defining the structure and behaviour of the training process. Below are some of the most common hyperparameters and their effects on training:

* **Batch** **size:** This refers to the number of images processed simultaneously in each training step. Smaller batch sizes are less demanding on memory and may enhance generalisation, although they can result in slower training. In contrast, larger batch sizes accelerate training but necessitate more GPU memory.

* **Epochs:** An epoch refers to a training cycle in which the model processes the entire training dataset. Increasing the number of epochs allows the model to learn more, but also raises the risk of overfitting. More is not always better; it is essential to monitor performance on the validation set.

* **Learning rate:** It determines the extent to which the model’s weights are adjusted during training. A high learning rate can result in quicker training but may overshoot the optimal solution. Conversely, a low learning rate provides more stable progress, although it may slow down convergence.

* **Optimizer:** An algorithm that updates weights to minimise the loss function. Common optimisers include SGD (stochastic gradient descent) and Adam (adaptive moment estimation), the latter being widely used for its adaptive learning rate and robust performance.

* **Learning rate scheduler:** Dynamically adjusts the learning rate during training, typically decreasing it after a specific number of epochs or when the validation loss plateaus. This approach helps balance rapid early learning with more refined convergence later on.

* **Patch size:** Instead of using full-resolution images, smaller patches are often utilised for training to reduce memory usage and enhance training speed. The patch size is determined by both available resources and the scale of the structures to be segmented.

* **Patience (early stopping):** This parameter defines the number of epochs to wait before halting training if the validation loss does not improve. It helps prevent wasting resources on overfitting and overtraining.

Given the many possible configurations, tuning hyperparameters is often essential—especially when applying a model to new data. Start with the recommended values from the model's original publication, but you might need to conduct a hyperparameter search to optimize performance. This can range from a simple grid search to more advanced methods, such as Gaussian-based processes or genetic algorithms.

### 3.5.4 Monitoring training and validation Losses {#monitoring-training-and-validation-losses}

Once your model begins training, it is helpful to evaluate its learning progress. The two key metrics for assessment are the training loss and the validation loss (**Figure 6**). Monitoring both throughout the training process offers insight into whether your model is improving and learning to generalise beyond the training data. The three main behaviours that you may encounter during training are:

![Figure 6](docs/9-figures/chapter9_6_Underfitting_VS_Overfitting.png)

**Figure 6: Monitoring training and validation losses during model training.** 

* **Underfitting:** The model has been trained with insufficient data or for too few epochs, resulting in similar training and validation losses, which is far from optimal.  
* **Good fitting:** Both training and validation losses decrease, with the validation loss slightly higher than the training loss, which is expected. This represents the ideal scenario.  
* **Overfitting:** The model achieves an excellent training loss, but the validation loss does not improve. This may indicate overly similar training data or excessive training epochs, preventing the model from generalising to new data.

##  3.6 Fine-Tuning Pre-existing Models {#fine-tuning-pre-existing-models}

Instead of training a model from scratch, fine-tuning an existing DL model is usually more efficient, especially when your data resembles the dataset used to train the original model. This approach utilises pre-trained weights and previously learned features, significantly decreasing the amount of required annotated data, training time, and computational resources.

### 3.6.1 Applying Transfer Learning {#applying-transfer-learning}

Transfer learning refers to the process of taking a pre-trained model and adapting it to a new but related task by providing task-specific training data, typically in the form of manually annotated image pairs (**Figure 7**). Transfer learning freezes part of the model (for instance, the initial layers or almost all the layers except the last ones); these weights will not be updated. Then, the model is trained on the new data, but only the layers that you have unfrozen will be updated. Since the base model already encodes many useful low-level features (e.g., edges, shapes, textures), this approach allows researchers to focus on refining the model for their specific biological structures or imaging modalities [(Li and Shen, 2018; Morid et al., 2021\)](https://www.zotero.org/google-docs/?F2ETNb) .

This method is especially effective when:

* You have limited training data available.  
* Your imaging conditions closely match those of the pre-trained model.  
* You wish to quickly adapt a general model to a specific dataset.

### 3.6.2 Conducting fine-tuning {#conducting-fine-tuning}

In classic fine-tuning, all layers of the pre-trained model are retrained, with their weights initialised from the original training (**Figure 7**) [(Archit et al., 2025; Pachitariu and Stringer, 2022\)](https://www.zotero.org/google-docs/?L9rdtN).  Thus, you continue training the full model using the new data. This approach allows the model to adjust more comprehensively to new data while still preserving the advantages of pre-learned features.

Classic fine-tuning is ideal when: 

* Your dataset is moderately different from the original training data (e.g., the same biological structure but different staining or modality).  
* You expect that earlier layers may need to adapt, not just the final classifier or output layers.  
* You have enough annotated data to avoid overfitting during full model training. Although this method is more computationally demanding than light fine-tuning, it often leads to better results on diverse datasets.

### 3.6.3 Iterative training: keeping humans in the loop {#iterative-training:-keeping-humans-in-the-loop}

Iterative fine-tuning is an interactive approach that combines model prediction with human annotation (see [Section 3.4.3](#accelerating-annotation-with-pre-trained-models)). The workflow typically starts with a pre-trained model predicting new images. A user then manually corrects or annotates these predictions, and the improved annotations update the model (**Figure 7**). This cycle continues, progressively enhancing the model’s accuracy with each iteration until it performs as expected [(Chen et al., 2020; Conrad and Narayan, 2023; Pachitariu and Stringer, 2022\)](https://www.zotero.org/google-docs/?LRuWLx).

This method is particularly powerful when:

* Annotated data is scarce or expensive to generate.   
* You're working with rare structures, unusual imaging conditions, or new experimental systems.  
* You want to efficiently build a custom model using feedback from domain experts.

![Figure 6](docs/9-figures/chapter9_6_Underfitting_VS_Overfitting.png)

**Figure 7: Strategies for training deep learning models for image segmentation.** A model can be trained from scratch using a large annotated dataset, fine-tuned from a pre-trained model with task-specific data, or refined through human-in-the-loop workflows where model predictions are manually corrected and fed back for retraining. These approaches balance performance, data availability, and annotation effort.

#### 

## 3.7 Evaluating the performance of your model {#evaluating-the-performance-of-your-model}

![Figure 8](docs/9-figures/chapter9_8_monitoring.png)

**Figure 8: Workflow for evaluating DL model performance during training and on test data.** Evaluating model performance is essential before deploying any DL model for image segmentation. This diagram outlines a two-stage process: assessment during training and on a separate test set. During training, validation and training losses (see [Section 3.5.4](https://docs.google.com/document/d/1S-F_79HMBBoJ9cm13fyXmYKSWlqcAdZIdqss1H4Hf2s/edit?pli=1&tab=t.0#heading=h.7bgsk7t5p8ac)) guide whether to continue training, stop, or expand the dataset. After training, performance is evaluated using a test set. High test metrics (e.g., IoU, F1-score) indicate readiness for deployment. Borderline or poor results suggest reviewing errors, refining training data, or trying a different model. This approach ensures model reliability and task-specific performance. 

With the rapid increase in DL tools and pre-trained models, it has become easier to use DL for image segmentation, but harder to determine which model will work best for your data. Regardless of how promising a model appears, you must always evaluate its performance before trusting its results. Evaluation is not optional; it is a critical step to ensure that the model meets the requirements of your specific task [(Laine et al., 2021\)](https://www.zotero.org/google-docs/?Fkq5PP) (**Figure 8**).

There are two main ways to evaluate a model:

* Qualitative evaluation entails visually inspecting the model's predictions. This approach can help you quickly identify clear errors or failures. It is effective for a small number of images, but it becomes impractical for large datasets or for comparing similar-looking outputs across multiple models.  
* Quantitative evaluation provides objective metrics for comparing models and tracking improvements. To achieve this, you need a small, labelled test set (typically 5 to 10 images with accurate ground truth segmentations). This test set must remain independent of your training and validation data to ensure an unbiased assessment.

Common metrics used in quantitative evaluation include:

* Intersection over Union (IoU), also known as the Jaccard Index, measures the overlap between the predicted segmentation and the ground truth.  
* F1-score (Dice coefficient): This is especially valuable when the object of interest covers a small area in the image, as it balances precision and recall.  
* True Positives (TP), False Positives (FP), and False Negatives (FN) are particularly important in semantic segmentation and can be used to calculate the IoU or F1 score.

For more information on these metrics, we recommend [(Laine et al., 2021\)](https://www.zotero.org/google-docs/?WjxQKF).

If a model fails to produce reasonable results, even on simple examples, you can often reject it based solely on qualitative inspection. However, in these cases, quantitative metrics can still help you understand how and where the model fails.

If your evaluation metrics indicate weak performance, especially for certain structures or image types, you may need to fine-tune the model (see [Section 3.6](#fine-tuning-pre-existing-models)). Consistently strong scores across various test images suggest that a model could be dependable and ready for deployment. If no pre-trained model meets your expectations, the best course may be to train your model using your images (see [Section 3.5](#training-a-segmentation-model-from-scratch)).

In summary, never skip evaluation. Every model must be tested—both visually and quantitatively—to ensure it truly works for your data and provides results you can trust.

## 3.8  Deploying your model on new data {#deploying-your-model-on-new-data}

Once a segmentation model has been trained and validated, it can be used on new, unseen images. This step typically involves feeding new images into the model to generate segmentation predictions. The deployment approach relies on the computational resources (see [Section 4.2](#managing-computational-resources)) as well as the size and complexity of your dataset (**Figure 9**). 

![Figure 9](docs/9-figures/chapter9_9_deployment.png)

**Figure 9: Decision workflow for model deployment strategy based on computational resources.** The choice of deployment strategy depends on the availability of computational resources (see [Section 4.2](https://docs.google.com/document/d/1S-F_79HMBBoJ9cm13fyXmYKSWlqcAdZIdqss1H4Hf2s/edit?pli=1&tab=t.0#heading=h.9x5jfmgrh00b)) and the sensitivity of the data . If high-performance computing resources are available locally, these should be used for deployment. In their absence, consider whether the data can be transferred to the cloud. If so, cloud-based resources offer an efficient solution. However, if data transfer is restricted—due to size or sensitivity—local deployment remains the only option, though it may require significantly more time. 

## 3.9 Troubleshooting Common Problems {#troubleshooting-common-problems}


**I found a tool or DL model online, but it does not work. What should I do?**

![Figure 10](docs/9-figures/chapter9_10_Does yout model work.png)

**Figure 10: Common deep learning segmentation problems and troubleshooting tips.**

**When should I train a model or segment manually?**

Refer to [Section 3.3.2](#when-to-train-your-model) for more details, but generally, this decision depends on your dataset and the performance of existing pre-trained models (**Figure 10**). If you only need to segment a small number of images, manually segmenting them is often the quickest and simplest solution. However, if you are dealing with a large dataset, it may be more efficient to annotate a small subset and use it to train a deep-learning model that can automate the segmentation of the rest.

**I decided to train my DL model, but it is not performing correctly. What should I do?**

First, ensure that you have trained the model for a sufficient number of epochs—this depends on the size of your dataset and the architecture of the model. Check the training loss: if it has plateaued, your model may be fully trained. If it is still decreasing, continue training.

If training is completed but results are poor, examine your data. Is the model missing specific features? Are there types of cells or structures that it consistently fails to segment? If so, ensure those examples are well represented and correctly annotated in your training data. You may need to enhance or expand your annotations.

If performance is poor, you may need additional annotated data to help the model generalise more effectively (**Figure 8**). Consider the following questions:

* Is my dataset balanced? Does it include sufficient examples of each structure or class I want to segment?  
* Am I training on one experimental batch while validating or testing on another?

**How many images should I have to train my model?**

Refer to [Section 2.1](#defining-your-segmentation-task-and-success-criteria) for more details. There’s no one-size-fits-all answer—it depends on the complexity of your task, your model architecture, and the variability in your data. More complex tasks typically require more data. Larger images can also be broken into more patches, effectively increasing your dataset size. While few-shot models are being developed for small datasets, most established DL models require a substantial amount of data.

**Possible technical issues that you may encounter when training your DL model.**

* The model predicts the same class for all pixels or segments in every cell. Your dataset might be unbalanced, containing too many similar examples. Adding more diverse or underrepresented examples can help the model learn to differentiate between classes.  
* Out-of-memory errors during training: Consider reducing the batch size or the image patch size. If that doesn't resolve the issue, consider switching to a workstation or cloud service with greater computational capacity.  
* The model performs well on training data but poorly on new images, suggesting overfitting (**Figure 6**). Implement data augmentation and increase dataset diversity to help the model generalise better.  
* Inconsistent results across different computers: Differences in GPUs or environments can cause slight variations in outcomes. If the differences are significant, verify that all systems use consistent software versions and configurations. For further information on this topic, refer to [Section 4.3](#ensuring-reproducibility-in-dl).

# 4. Further considerations for DL segmentation {#further-considerations-for-dl-segmentation}

   ## 4.1 Choosing the Right Tools for DL {#choosing-the-right-tools-for-dl}

Selecting the right tools to train and use DL models depends mainly on your level of programming experience and comfort with technical interfaces.

If you prefer not to write code or use command-line tools, opt for platforms that offer graphical user interfaces (GUIs) or interactive notebooks with pre-configured workflows. These tools let you perform powerful segmentation tasks using intuitive interfaces and simple widgets.

GUI-based tools include, for instance :

* Cellpose GUI  
* Fiji with DeepImageJ and StarDist plugins  
* Napari  
* Ilastik  
* QuPath

Interactive Jupyter notebooks provide a flexible balance between code and GUI. They enable you to execute code in manageable steps (cells) and immediately see the results. Tools like ZeroCostDL4Mic, BiaPy, and DL4MicEverywhere [(Hidalgo-Cenalmor et al., 2024\)](https://www.zotero.org/google-docs/?3CQnFS) leverage Jupyter notebooks, concealing complex code behind user-friendly interfaces. These platforms cater to users with little or no coding experience while still allowing advanced users to access and modify code as needed. ZeroCostDL4Mic, in particular, established a widely adopted framework for training DL models via notebooks, contributing to the standardisation and simplification of the workflow.

If you are comfortable with programming, you will have even more flexibility. Languages such as Python, MATLAB, Julia, Java, and Rust provide options for building and customizing deep learning workflows. Python stands out as the most beginner-friendly and widely supported choice, boasting a large ecosystem of libraries and community support. Popular Python libraries for deep learning include PyTorch, TensorFlow, Keras, and JAX.

While coding can involve a steeper learning curve, it allows you to create customized pipelines, integrate various tools, and troubleshoot intricate workflows, unlocking the full potential of DL for microscopy segmentation.

## 4.2  Managing Computational Resources {#managing-computational-resources}

When using DL for microscopy, an important consideration is the availability and capacity of your computational resources (**Figure 9**). High-performance DL models, particularly those used for 3D image data, can be very demanding regarding memory and processing power. 

When selecting or designing a DL model, evaluate your available infrastructure:

* GPU memory: Determines how large your model and batch size can be.  
* Training time: Influences your ability to iterate quickly; simpler models train faster.  
* Dataset size: Larger datasets benefit from more powerful hardware and longer training times.

A practical strategy involves starting with lightweight models that demand fewer resources and scaling up to more complex architectures only if performance improvements become necessary. Tools like StarDist and Cellpose, for example, provide efficient options that function effectively with relatively modest hardware.

Additionally, consider whether to train and deploy your model locally or in the cloud (**Figure 11**). Local training is more feasible if you already possess compatible hardware, while cloud services like Google Colab or AWS provide access to more powerful resources without needing to invest in hardware. Cloud-based workflows are particularly advantageous for training large models or managing 3D data.

![Figure 11](docs/9-figures/chapter9_11_what resources to use when trainig.png)

**Figure 11: Training and deployment strategies for DL models in microscopy.** Depending on the available tools and infrastructure, models can be trained and deployed locally or in the cloud. Modified from [(von Chamier et al., 2021\)](https://www.zotero.org/google-docs/?zhVvst).

## 4.3 Ensuring Reproducibility in DL {#ensuring-reproducibility-in-dl}

When sharing how you trained a DL model, two key elements often come to mind: the dataset used and the code that runs the model. However, in practice, reproducibility extends beyond just data and code. In programming environments like Python, which rely heavily on external libraries, ensuring reproducibility also requires capturing the exact configuration of the environment in which the model was trained.

DL models are sensitive to changes in library versions and dependencies. Even minor differences in the software stack can result in inconsistent outcomes or training failures. While sharing a list of dependencies (e.g., a requirements.txt or a Conda environment file) is a constructive step, differences in operating systems or local setups can still lead to issues.

A robust and increasingly popular solution is containerisation. Containers package software, dependencies, and environment settings into a portable and self-contained unit. One of the most widely used containerization tools is Docker. A Docker container can be considered a lightweight, standalone virtual machine that includes everything needed to run code, such as the operating system, libraries, and runtime, ensuring applications run consistently across different machines.

Using containers ensures that your model training and inference processes remain consistent, no matter who executes them or where they are conducted. This greatly simplifies the ability of collaborators or reviewers to reproduce your results.

For researchers unfamiliar with software development, tools like DL4MicEverywhere [(Hidalgo-Cenalmor et al., 2024\)](https://www.zotero.org/google-docs/?hSZPhL) and bia-binder [(Russell et al., 2024\)](https://www.zotero.org/google-docs/?SKCngf) simplify the use of containers by integrating them into user-friendly Jupyter notebook environments. These platforms enable researchers to benefit from the reproducibility of containers without needing to manage complex setups or command-line tools.

Reproducibility is crucial for establishing trust in computational results and facilitating long-term scientific collaboration. To ensure your DL workflows are reproducible, follow these best practices:

* Pin every software version used in your workflow.  
* Document your environment setup thoroughly.  
* Provide a containerised version of your training and inference pipeline when possible.  
* Taking these steps will make it easier for others to reproduce your results, build on your work, and apply your models in different research settings.

For more information on best practices, consult [(Laine et al., 2021\)](https://www.zotero.org/google-docs/?JQTcnl).

# 5. Summary & Outlook {#summary-&-outlook}

Segmenting microscopy images remains a critical yet challenging task in bioimage analysis. DL has undeniably transformed this field, offering robust solutions for segmenting complex and variable structures. However, as this chapter emphasizes, DL is not always the fastest or the best approach. Classical image processing techniques or pixel classifiers often provide faster, simpler, and highly effective alternatives in many scenarios.

The decision to use DL should be driven by the complexity of the task, the availability of annotated data, and the specific goals of the segmentation project. Successful DL implementations often require significant investments in data curation, annotation, and computational resources. Furthermore, training from scratch is frequently avoidable thanks to the growing ecosystem of pre-trained models and resources shared by the community.

Notably, the landscape of DL segmentation is rapidly evolving. The emergence of foundation models, which are large, versatile networks pre-trained on vast and diverse datasets, promises to further lower the barriers to entry [(Archit et al., 2025\)](https://www.zotero.org/google-docs/?RyKeFx). These models enable transfer learning, fine-tuning, and even zero-shot segmentation, where accurate predictions can be made on previously unseen data with minimal or no task-specific training. This shift opens exciting new avenues for researchers who previously lacked the resources or expertise to apply DL in their work.

The ongoing development and democratization of DL tools, along with enhancements in model generalizability, human-in-the-loop workflows, and reproducibility, are changing how microscopy data is analyzed. Still, the key to successful segmentation will always involve careful planning, quality control, and selecting the right tool for the task, whether it involves deep learning or not.

# 6. **References** {#references}

   [**Ahlers, J., Althviz Moré, D., Amsalem, O., Anderson, A., Bokota, G., Boone, P., Bragantini, J., Buckley, G., Burt, A., Bussonnier, M., et al.** (2023). napari: a multi-dimensional image viewer for Python.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Archit, A., Freckmann, L., Nair, S., Khalid, N., Hilt, P., Rajashekar, V., Freitag, M., Teuber, C., Buckley, G., von Haaren, S., et al.** (2025). Segment Anything for Microscopy. *Nat Methods* **22**, 579–591.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Arganda-Carreras, I., Kaynig, V., Rueden, C., Eliceiri, K. W., Schindelin, J., Cardona, A. and Sebastian Seung, H.** (2017). Trainable Weka Segmentation: a machine learning tool for microscopy pixel classification. *Bioinformatics* **33**, 2424–2426.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Arzt, M., Deschamps, J., Schmied, C., Pietzsch, T., Schmidt, D., Tomancak, P., Haase, R. and Jug, F.** (2022). LABKIT: Labeling and Segmentation Toolkit for Big Image Data. *Frontiers in Computer Science* **4**,.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Bankhead, P., Loughrey, M. B., Fernández, J. A., Dombrowski, Y., McArt, D. G., Dunne, P. D., McQuaid, S., Gray, R. T., Murray, L. J., Coleman, H. G., et al.** (2017). QuPath: Open source software for digital pathology image analysis. *Sci Rep* **7**, 16878\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Bannon, D., Moen, E., Schwartz, M., Borba, E., Kudo, T., Greenwald, N., Vijayakumar, V., Chang, B., Pao, E., Osterman, E., et al.** (2021). DeepCell Kiosk: scaling deep learning–enabled cellular image analysis with Kubernetes. *Nat Methods* **18**, 43–45.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Bejarano, L., Kauzlaric, A., Lamprou, E., Lourenco, J., Fournier, N., Ballabio, M., Colotti, R., Maas, R., Galland, S., Massara, M., et al.** (2024). Interrogation of endothelial and mural cells in brain metastasis reveals key immune-regulatory mechanisms. *Cancer Cell* **42**, 378-395.e10.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Berg, S., Kutra, D., Kroeger, T., Straehle, C. N., Kausler, B. X., Haubold, C., Schiegg, M., Ales, J., Beier, T., Rudy, M., et al.** (2019). ilastik: interactive machine learning for (bio)image analysis. *Nat Methods* **16**, 1226–1232.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Caicedo, J. C., McQuin, C., Goodman, A., Singh, S. and Carpenter, A. E.** (2018). Weakly Supervised Learning of Single-Cell Feature Embeddings. In *2018 IEEE/CVF Conference on Computer Vision and Pattern Recognition*, pp. 9309–9318.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Cardoso, M. J., Li, W., Brown, R., Ma, N., Kerfoot, E., Wang, Y., Murrey, B., Myronenko, A., Zhao, C., Yang, D., et al.** (2022). MONAI: An open-source framework for deep learning in healthcare.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Chen, J., Ding, L., Viana, M. P., Lee, H., Sluezwski, M. F., Morris, B., Hendershott, M. C., Yang, R., Mueller, I. A. and Rafelski, S. M.** (2020). The Allen Cell and Structure Segmenter: a new open source toolkit for segmenting 3D intracellular structures in fluorescence microscopy images. 491035\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Conrad, R. and Narayan, K.** (2023). Instance segmentation of mitochondria in electron microscopy images with a generalist deep learning model trained on a diverse dataset. *Cell Systems* **14**, 58-71.e5.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Fazeli, E., Roy, N. H., Follain, G., Laine, R. F., von Chamier, L., Hänninen, P. E., Eriksson, J. E., Tinevez, J.-Y. and Jacquemet, G.** (2020). Automated cell tracking using StarDist and TrackMate. *F1000Res* **9**, 1279\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Fisch, D., Zhang, T., Sun, H., Ma, W., Tan, Y., Gygi, S. P., Higgins, D. E. and Kagan, J. C.** (2024). Molecular definition of the endogenous Toll-like receptor signalling pathways. *Nature* **631**, 635–644.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Follain, G., Ghimire, S., Pylvänäinen, J. W., Vaitkevičiūtė, M., Wurzinger, D., Guzmán, C., Conway, J. R., Dibus, M., Oikari, S., Rilla, K., et al.** (2024). Fast label-free live imaging reveals key roles of flow dynamics and CD44-HA interaction in cancer cell arrest on endothelial monolayers. 2024.09.30.615654.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Heinrich, L., Bennett, D., Ackerman, D., Park, W., Bogovic, J., Eckstein, N., Petruncio, A., Clements, J., Pang, S., Xu, C. S., et al.** (2021). Whole-cell organelle segmentation in volume electron microscopy. *Nature* **599**, 141–146.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Hidalgo-Cenalmor, I., Pylvänäinen, J. W., G. Ferreira, M., Russell, C. T., Saguy, A., Arganda-Carreras, I., Shechtman, Y., AI4Life Horizon Europe Program Consortium, Muñoz-Barrutia, A., Serrano-Solano, B., et al.** (2024). DL4MicEverywhere: deep learning for microscopy made flexible, shareable and reproducible. *Nat Methods*.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Kochetov, B., Bell, P. D., Garcia, P. S., Shalaby, A. S., Raphael, R., Raymond, B., Leibowitz, B. J., Schoedel, K., Brand, R. M., Brand, R. E., et al.** (2024). UNSEG: unsupervised segmentation of cells and their nuclei in complex tissue samples. *Commun Biol* **7**, 1–14.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Krizhevsky, A., Sutskever, I. and Hinton, G. E.** (2012). ImageNet Classification with Deep Convolutional Neural Networks. In *Advances in Neural Information Processing Systems*, p. Curran Associates, Inc.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Laine, R. F., Arganda-Carreras, I., Henriques, R. and Jacquemet, G.** (2021). Avoiding a replication crisis in deep-learning-based bioimage analysis. *Nat Methods* **18**, 1136–1144.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Lecun, Y., Bottou, L., Bengio, Y. and Haffner, P.** (1998). Gradient-based learning applied to document recognition. *Proceedings of the IEEE* **86**, 2278–2324.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Li, Y. and Shen, L.** (2018). cC-GAN: A Robust Transfer-Learning Framework for HEp-2 Specimen Image Segmentation. *IEEE Access* **6**, 14048–14058.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Lin, B., Emami, N., Santos, D. A., Luo, Y., Banerjee, S. and Xu, B.-X.** (2022). A deep learned nanowire segmentation model using synthetic data augmentation. *npj Comput Mater* **8**, 1–12.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Liu, B., Polack, M., Coudray, N., Claudio Quiros, A., Sakellaropoulos, T., Le, H., Karimkhan, A., Crobach, A. S. L. P., van Krieken, J. H. J. M., Yuan, K., et al.** (2025). Self-supervised learning reveals clinically relevant histomorphological patterns for therapeutic strategies in colon cancer. *Nat Commun* **16**, 2328\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Moen, E., Bannon, D., Kudo, T., Graf, W., Covert, M. and Van Valen, D.** (2019). Deep learning for cellular image analysis. *Nature Methods* **16**, 1233–1246.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Morid, M. A., Borjali, A. and Del Fiol, G.** (2021). A scoping review of transfer learning research on medical image analysis using ImageNet. *Computers in Biology and Medicine* **128**, 104115\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Moshkov, N., Bornholdt, M., Benoit, S., Smith, M., McQuin, C., Goodman, A., Senft, R. A., Han, Y., Babadi, M., Horvath, P., et al.** (2024). Learning representations for image-based profiling of perturbations. *Nat Commun* **15**, 1594\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Ouyang, W., Beuttenmueller, F., Gómez-de-Mariscal, E., Pape, C., Burke, T., Garcia-López-de-Haro, C., Russell, C., Moya-Sans, L., de-la-Torre-Gutiérrez, C., Schmidt, D., et al.** (2022). BioImage Model Zoo: A Community-Driven Resource for Accessible Deep Learning in BioImage Analysis. 2022.06.07.495102.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Pachitariu, M. and Stringer, C.** (2022). Cellpose 2.0: how to train your own model. *Nat Methods* 1–8.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Pylvänäinen, J. W., Gómez-de-Mariscal, E., Henriques, R. and Jacquemet, G.** (2023). Live-cell imaging in the deep learning era. *Current Opinion in Cell Biology* **85**, 102271\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Rangel DaCosta, L., Sytwu, K., Groschner, C. K. and Scott, M. C.** (2024). A robust synthetic data generation framework for machine learning in high-resolution transmission electron microscopy (HRTEM). *npj Comput Mater* **10**, 1–11.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Ronneberger, O., Fischer, P. and Brox, T.** (2015). U-Net: Convolutional Networks for Biomedical Image Segmentation.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Russell, C. T., Burel, J.-M., Athar, A., Li, S., Sarkans, U., Swedlow, J., Brazma, A., Hartley, M. and Uhlmann, V.** (2024). bia-binder: A web-native cloud compute service for the bioimage analysis community.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Schindelin, J., Arganda-Carreras, I., Frise, E., Kaynig, V., Longair, M., Pietzsch, T., Preibisch, S., Rueden, C., Saalfeld, S., Schmid, B., et al.** (2012). Fiji: an open-source platform for biological-image analysis. *Nature Methods* **9**, 676–682.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Schmidt, U., Weigert, M., Broaddus, C. and Myers, G.** (2018). Cell Detection with Star-Convex Polygons. In *Medical Image Computing and Computer Assisted Intervention – MICCAI 2018* (ed. Frangi, A. F.), Schnabel, J. A.), Davatzikos, C.), Alberola-López, C.), and Fichtinger, G.), pp. 265–273. Cham: Springer International Publishing.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Shorten, C. and Khoshgoftaar, T. M.** (2019). A survey on Image Data Augmentation for Deep Learning. *Journal of Big Data* **6**, 60\.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**Stringer, C., Wang, T., Michaelos, M. and Pachitariu, M.** (2021). Cellpose: a generalist algorithm for cellular segmentation. *Nat Methods* **18**, 100–106.](https://www.zotero.org/google-docs/?Wwiyoi)

   [**von Chamier, L., Laine, R. F., Jukkala, J., Spahn, C., Krentzel, D., Nehme, E., Lerche, M., Hernández-Pérez, S., Mattila, P. K., Karinou, E., et al.** (2021). Democratising deep learning for microscopy with ZeroCostDL4Mic. *Nature Communications* **12**, 2276\.](https://www.zotero.org/google-docs/?Wwiyoi)


---

# Training and Using Your Own Models
<!--Your first header will be the chapter's upper-level table of contents title.-->
<!--If you'd like to have a subtitle, include it in the Quarto header above -->

Under your first header, include a brief introduction to your chapter.

Starting prompt for this chapter: Chapter 9 discusses the considerations (e.g., over/under-fitting, parameter choices) for training a new model and tools to help getting started (e.g. DL4MicEverywhere). It should include a primer on cloud-based computing tools such as Docker, Google Colab, etc. to highlight the potential for training models without bespoke hardware in house. This chapter should demonstrate a walk-through of training a model for segmentation, following the throughline of the book.

## Include section headers as appropriate

Use markdown heading level two for section headers. You can use standard markdown formatting, for example _emphasize the end of this sentence_.

This is a new paragraph with more text. Your paragraphs can cross reference other items, such as @fig-simple. Use `fig` to reference figures, and `eq` to reference equations, such as @eq-stddev.

###  Sub-subsection headers are also available

To make your sections cross reference-able throughout the book, include a section reference, as shown in the header for @sec-equation.

## Bibliography and Citations

To cite a research article, add it to references.bib and then refer to the citation key. For example, reference @stringer2021 refers to CellPose and reference @von_chamier2021 refers to ZeroCostDL4Mic.

## Adding to the Glossary

We are using the extension [Quarto-glossary](https://debruine.github.io/quarto-glossary/#styles) to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from {{< glossary hallucinations >}}. It is important to understand the underlying {{< glossary "training data" >}} to interpret your results. Clicking on the word will reveal its definition. The complete glossary for the book will be listed in the [Glossary](glossary.qmd).

## Code and Equations {#sec-equation}

This is an example of including a python snippet that generates a figure

```{python}
#| label: fig-simple
#| fig-cap: "Simple Plot"
import matplotlib.pyplot as plt
plt.plot([1,23,2,4])
plt.show()
```


In some cases, you may want to include a code-block that is not executed when the book is compiled. Use the `eval: false` option for this.

```{python}
#| eval: false
import matplotlib.pyplot as plt
plt.plot([1,23,2,4])
plt.show()
```


Figures can also be generated that do not show the code by using the option for `code-fold: true`.

```{python}
#| code-fold: true
#| label: fig-polar
#| fig-cap: "A spiral on a polar axis"
#| fig-alt: "A line plot on a polar axis. The line spirals out from a value of zero to a value of 2."

import numpy as np
import matplotlib.pyplot as plt

r = np.arange(0, 2, 0.01)
theta = 2 * np.pi * r
fig, ax = plt.subplots(
  subplot_kw = {'projection': 'polar'} 
)
ax.plot(theta, r)
ax.set_rticks([0.5, 1, 1.5, 2])
ax.grid(True)
plt.show()
```

Here is an example equation.

$$
s = \sqrt{\frac{1}{N-1} \sum_{i=1}^N (x_i - \overline{x})^2}
$$ {#eq-stddev}

### Embedding Figures

You can also embed figures from other notebooks in the repo as shown in the following embed example.


{{< embed ../notebooks/test.ipynb#fig-test-fig echo-true >}}

When embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, `chapter4_example_u-net.ipynb`. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code--but not for rendering the book at large--will be installed there. That way, we will not need to handle a global environment across the book.

## Quarto has additional features.

You can learn more about markdown options and additional Quarto features in the [Quarto documentation](https://quarto.org/docs/authoring/markdown-basics.html).  One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.

::: {.callout-note}
Note that there are five types of callouts, including:
`note`, `tip`, `warning`, `caution`, and `important`. They can default to open (like this example) or collapsed (example below).
:::

::: {.callout-tip collapse="true"}
These could be good for extra material or exercises.
:::

::: {.callout-caution}
There are caveats when applying these tools. Expand the code below to learn more.

```{python}
#| code-fold: true
r = np.arange(0, 2, 0.01)
theta = 2 * np.pi * r
```
:::

::: {.callout-warning}
Be careful to avoid hallucinations.
:::

::: {.callout-important}
This is key information.
:::
