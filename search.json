[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AI in Microscopy: A BioImaging Guide",
    "section": "",
    "text": "Welcome\nThis is an initial outline for the welcome page:\n\nInclude a very brief introduction of the book (this is not the introduction chapter).\nExplain how to interact with the book. For example, explain how code snippets work for the reader, links to figures, glossary terms, etc.\nState the licensing and use restrictions.\nHow to cite the book.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "1-intro.html",
    "href": "1-intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 1 outlines how AI can span experimental design, image acquisition, image processing, and analysis (without discussing what AI is from a technical perspective). This chapter will also outline the roadmap of the book which will largely focus on acquisition and processing.\nTopics suggested during the authors’ meetings: Discuss that AI is not always solution and talk about when it is actually useful. Discuss that there are many types of microscopy images and each will have their own AI considerations (e.g., imaging modality, 2D vs 3D, static vs time lapse).\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1-intro.html#include-section-headers-as-appropriate",
    "href": "1-intro.html#include-section-headers-as-appropriate",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1-intro.html#bibliography-and-citations",
    "href": "1-intro.html#bibliography-and-citations",
    "title": "1  Introduction",
    "section": "1.2 Bibliography and Citations",
    "text": "1.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1-intro.html#adding-to-the-glossary",
    "href": "1-intro.html#adding-to-the-glossary",
    "title": "1  Introduction",
    "section": "1.3 Adding to the Glossary",
    "text": "1.3 Adding to the Glossary\nWe are using R code to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data, validation data and false positives to interpret your results. Clicking on the word will reveal its definition by taking you to the entry on the Glossary page. Pressing back in your browser will return you to your previous place in the textbook.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1-intro.html#sec-equation",
    "href": "1-intro.html#sec-equation",
    "title": "1  Introduction",
    "section": "1.4 Code and Equations",
    "text": "1.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 1.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{1.1}\\]\n\n1.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 1.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1-intro.html#quarto-has-additional-features.",
    "href": "1-intro.html#quarto-has-additional-features.",
    "title": "1  Introduction",
    "section": "1.5 Quarto has additional features.",
    "text": "1.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "2-primer.html",
    "href": "2-primer.html",
    "title": "2  AI Primer",
    "section": "",
    "text": "2.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 2 demystifies Artificial Intelligence for microscopy users. It should define terms (e.g., machine/deep learning, supervised/unsupervised learning) without programming details such that an educated scientist without AI experience can understand how these concepts apply to microscopy in life sciences. The use-cases and strengths of different approaches for different applications should be discussed (e.g., contrasting unsupervised clustering vs supervised segmentation). This chapter should broadly introduce image restoration and segmentation, as they will be themes throughout.\nSuggestion from authors’ meetings: This chapter can draw on the outlines from other chapters to introduce key topics for the following chapters.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>AI Primer</span>"
    ]
  },
  {
    "objectID": "2-primer.html#include-section-headers-as-appropriate",
    "href": "2-primer.html#include-section-headers-as-appropriate",
    "title": "2  AI Primer",
    "section": "",
    "text": "2.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>AI Primer</span>"
    ]
  },
  {
    "objectID": "2-primer.html#bibliography-and-citations",
    "href": "2-primer.html#bibliography-and-citations",
    "title": "2  AI Primer",
    "section": "2.2 Bibliography and Citations",
    "text": "2.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>AI Primer</span>"
    ]
  },
  {
    "objectID": "2-primer.html#adding-to-the-glossary",
    "href": "2-primer.html#adding-to-the-glossary",
    "title": "2  AI Primer",
    "section": "2.3 Adding to the Glossary",
    "text": "2.3 Adding to the Glossary\nWe are using R code to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data, validation data and false positives to interpret your results. Clicking on the word will reveal its definition by taking you to the entry on the Glossary page. Pressing back in your browser will return you to your previous place in the textbook.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>AI Primer</span>"
    ]
  },
  {
    "objectID": "2-primer.html#sec-equation",
    "href": "2-primer.html#sec-equation",
    "title": "2  AI Primer",
    "section": "2.4 Code and Equations",
    "text": "2.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 2.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{2.1}\\]\n\n2.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 2.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>AI Primer</span>"
    ]
  },
  {
    "objectID": "2-primer.html#quarto-has-additional-features.",
    "href": "2-primer.html#quarto-has-additional-features.",
    "title": "2  AI Primer",
    "section": "2.5 Quarto has additional features.",
    "text": "2.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>AI Primer</span>"
    ]
  },
  {
    "objectID": "3-llms.html",
    "href": "3-llms.html",
    "title": "3  Foundations of Large Language Models",
    "section": "",
    "text": "3.1 Multi-modal AI: Vision-Language Models and Generative AI\nIn recent years, large language models (LLMs) have revolutionized how we interact with technology, bringing unprecedented capabilities to scientific research including microscopy. This chapter explores how microscopists can leverage these powerful AI tools to enhance their workflow, from learning concepts to automating analysis tasks. We’ll discuss both general-purpose and microscopy-specific tools while highlighting practical applications and potential pitfalls.\nThis section introduces the fundamental concepts behind modern language models, focusing on transformer architectures that power tools like ChatGPT. We’ll explain how these models function, their capabilities for understanding scientific text, and their emerging role in generating code for image analysis tasks. We’ll demonstrate how microscopists can effectively use LLMs to learn new concepts, troubleshoot methods, and generate starting points for analysis scripts.\nMoving beyond text-only interfaces, multi-modal models combine language understanding with visual processing capabilities. This section explores how Vision-Language Models (VLMs) like GPT-4o can “see” and interpret microscopy images, assist with image annotation, and even aid in experimental design. We’ll also cover generative AI technologies including diffusion models that can create synthetic training data, perform style transfer, or convert microscopy images into vector graphics for publications.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Foundations of Large Language Models</span>"
    ]
  },
  {
    "objectID": "3-llms.html#sec-ai-agents",
    "href": "3-llms.html#sec-ai-agents",
    "title": "3  Foundations of Large Language Models",
    "section": "3.2 AI Agents for Microscopy Workflows",
    "text": "3.2 AI Agents for Microscopy Workflows\nAI agents represent the next evolution - autonomous systems that combine language understanding with specialized scientific knowledge and the ability to execute actions. We’ll examine microscopy-specific tools like Omega and the BioImage.io chatbot that can perform complex bioimage analysis workflows through natural language instructions. This section will explore chain-of-thought reasoning, code generation and execution capabilities, and how these agents use visual feedback to iteratively improve results.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Foundations of Large Language Models</span>"
    ]
  },
  {
    "objectID": "3-llms.html#sec-challenges",
    "href": "3-llms.html#sec-challenges",
    "title": "3  Foundations of Large Language Models",
    "section": "3.3 Challenges and Limitations",
    "text": "3.3 Challenges and Limitations\nWhile powerful, AI assistants come with significant limitations that microscopists must understand. This section addresses critical challenges including: - hallucinations and factual errors in generated content - The “black box” nature of models and concerns about reproducibility - Alignment problems when tools lack domain-specific knowledge - The need for human validation and the dangers of overreliance - Practical strategies for steering models toward scientifically valid outputs",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Foundations of Large Language Models</span>"
    ]
  },
  {
    "objectID": "3-llms.html#sec-future",
    "href": "3-llms.html#sec-future",
    "title": "3  Foundations of Large Language Models",
    "section": "3.4 Future Directions",
    "text": "3.4 Future Directions\nThe intersection of LLMs and microscopy is rapidly evolving. This final section examines emerging capabilities and future possibilities, including: - Generalist vision-language models capable of performing diverse analysis tasks - Models that can directly transform input images into processed outputs - The integration of AI agents with microscope hardware for fully autonomous imaging - Smart microscopy systems that adapt acquisition parameters based on real-time image understanding - Ethical considerations and best practices for responsible AI adoption in biological research",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Foundations of Large Language Models</span>"
    ]
  },
  {
    "objectID": "3-llms.html#sec-practical-guide",
    "href": "3-llms.html#sec-practical-guide",
    "title": "3  Foundations of Large Language Models",
    "section": "3.5 Practical Guide: Getting Started with LLMs for Microscopy",
    "text": "3.5 Practical Guide: Getting Started with LLMs for Microscopy\nThis hands-on section provides step-by-step guidance for microscopists to begin leveraging LLMs effectively, including: - Crafting effective prompts that produce reliable, scientific outputs - Using ChatGPT and similar tools to learn imaging concepts and generate analysis code - Getting started with BioImage.io tools and microscopy-specific AI agents - Strategies for validating and verifying AI-generated solutions - Example workflows demonstrating LLM integration into real microscopy analysis tasks",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Foundations of Large Language Models</span>"
    ]
  },
  {
    "objectID": "4-architectures.html",
    "href": "4-architectures.html",
    "title": "4  Architectures and Loss Models",
    "section": "",
    "text": "4.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 4 introduces architectures and loss models, defining them and providing examples through two practical case studies: image restoration and segmentation. Although this chapter will include code snippets/exercises, the presentation of essential concepts should communicate the philosophy behind the choice of a model for non-programmers.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Architectures and Loss Models</span>"
    ]
  },
  {
    "objectID": "4-architectures.html#include-section-headers-as-appropriate",
    "href": "4-architectures.html#include-section-headers-as-appropriate",
    "title": "4  Architectures and Loss Models",
    "section": "",
    "text": "4.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Architectures and Loss Models</span>"
    ]
  },
  {
    "objectID": "4-architectures.html#bibliography-and-citations",
    "href": "4-architectures.html#bibliography-and-citations",
    "title": "4  Architectures and Loss Models",
    "section": "4.2 Bibliography and Citations",
    "text": "4.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Architectures and Loss Models</span>"
    ]
  },
  {
    "objectID": "4-architectures.html#adding-to-the-glossary",
    "href": "4-architectures.html#adding-to-the-glossary",
    "title": "4  Architectures and Loss Models",
    "section": "4.3 Adding to the Glossary",
    "text": "4.3 Adding to the Glossary\nWe are using R code to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data, validation data and false positives to interpret your results. Clicking on the word will reveal its definition by taking you to the entry on the Glossary page. Pressing back in your browser will return you to your previous place in the textbook.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Architectures and Loss Models</span>"
    ]
  },
  {
    "objectID": "4-architectures.html#sec-equation",
    "href": "4-architectures.html#sec-equation",
    "title": "4  Architectures and Loss Models",
    "section": "4.4 Code and Equations",
    "text": "4.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 4.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 4.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{4.1}\\]\n\n4.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 4.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Architectures and Loss Models</span>"
    ]
  },
  {
    "objectID": "4-architectures.html#quarto-has-additional-features.",
    "href": "4-architectures.html#quarto-has-additional-features.",
    "title": "4  Architectures and Loss Models",
    "section": "4.5 Quarto has additional features.",
    "text": "4.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "Getting Started with AI",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Architectures and Loss Models</span>"
    ]
  },
  {
    "objectID": "5-training-data.html",
    "href": "5-training-data.html",
    "title": "5  Collecting Training Data",
    "section": "",
    "text": "5.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 5 discusses collecting, annotating and validating training data. It should highlight potential pitfalls such as balanced data sets, out-of-distribution problems, etc. It should also address the question: how do you collect training data on your microscope? For example, this chapter should discuss collecting low/high-laser power pairs for the purpose of training an image restoration model.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collecting Training Data</span>"
    ]
  },
  {
    "objectID": "5-training-data.html#include-section-headers-as-appropriate",
    "href": "5-training-data.html#include-section-headers-as-appropriate",
    "title": "5  Collecting Training Data",
    "section": "",
    "text": "5.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collecting Training Data</span>"
    ]
  },
  {
    "objectID": "5-training-data.html#bibliography-and-citations",
    "href": "5-training-data.html#bibliography-and-citations",
    "title": "5  Collecting Training Data",
    "section": "5.2 Bibliography and Citations",
    "text": "5.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collecting Training Data</span>"
    ]
  },
  {
    "objectID": "5-training-data.html#adding-to-the-glossary",
    "href": "5-training-data.html#adding-to-the-glossary",
    "title": "5  Collecting Training Data",
    "section": "5.3 Adding to the Glossary",
    "text": "5.3 Adding to the Glossary\nWe are using R code to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data, validation data and false positives to interpret your results. Clicking on the word will reveal its definition by taking you to the entry on the Glossary page. Pressing back in your browser will return you to your previous place in the textbook.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collecting Training Data</span>"
    ]
  },
  {
    "objectID": "5-training-data.html#sec-equation",
    "href": "5-training-data.html#sec-equation",
    "title": "5  Collecting Training Data",
    "section": "5.4 Code and Equations",
    "text": "5.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 5.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 5.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{5.1}\\]\n\n5.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 5.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collecting Training Data</span>"
    ]
  },
  {
    "objectID": "5-training-data.html#quarto-has-additional-features.",
    "href": "5-training-data.html#quarto-has-additional-features.",
    "title": "5  Collecting Training Data",
    "section": "5.5 Quarto has additional features.",
    "text": "5.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Collecting Training Data</span>"
    ]
  },
  {
    "objectID": "6-image-restoration.html",
    "href": "6-image-restoration.html",
    "title": "6  Extending Your Hardware With AI",
    "section": "",
    "text": "6.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: This image restoration focused chapter motivates how AI can improve the image quality beyond hardware limitations. This chapter should include image restoration (denoising) and sensor-less AO (deep-learning-based AO); other topics can be included at the author’s discretion.\nNotes from the authors’ meeting: This chapter can start with a broader overview of the topic, which will reference existing reviews on the topic. Then the chapter will focus on a denoising tutorial, which will include discussions of potential pitfalls and best practices.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Extending Your Hardware With AI</span>"
    ]
  },
  {
    "objectID": "6-image-restoration.html#include-section-headers-as-appropriate",
    "href": "6-image-restoration.html#include-section-headers-as-appropriate",
    "title": "6  Extending Your Hardware With AI",
    "section": "",
    "text": "6.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Extending Your Hardware With AI</span>"
    ]
  },
  {
    "objectID": "6-image-restoration.html#bibliography-and-citations",
    "href": "6-image-restoration.html#bibliography-and-citations",
    "title": "6  Extending Your Hardware With AI",
    "section": "6.2 Bibliography and Citations",
    "text": "6.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Extending Your Hardware With AI</span>"
    ]
  },
  {
    "objectID": "6-image-restoration.html#adding-to-the-glossary",
    "href": "6-image-restoration.html#adding-to-the-glossary",
    "title": "6  Extending Your Hardware With AI",
    "section": "6.3 Adding to the Glossary",
    "text": "6.3 Adding to the Glossary\nWe are using the extension Quarto-glossary to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data to interpret your results. Clicking on the word will reveal its definition. The complete glossary for the book will be listed in the Glossary.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Extending Your Hardware With AI</span>"
    ]
  },
  {
    "objectID": "6-image-restoration.html#sec-equation",
    "href": "6-image-restoration.html#sec-equation",
    "title": "6  Extending Your Hardware With AI",
    "section": "6.4 Code and Equations",
    "text": "6.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 6.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 6.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{6.1}\\]\n\n6.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 6.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Extending Your Hardware With AI</span>"
    ]
  },
  {
    "objectID": "6-image-restoration.html#quarto-has-additional-features.",
    "href": "6-image-restoration.html#quarto-has-additional-features.",
    "title": "6  Extending Your Hardware With AI",
    "section": "6.5 Quarto has additional features.",
    "text": "6.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Extending Your Hardware With AI</span>"
    ]
  },
  {
    "objectID": "7-smart-microscopy.html",
    "href": "7-smart-microscopy.html",
    "title": "7  Adding AI to Your Hardware",
    "section": "",
    "text": "Introduction\n\nDefine and motivate the “problem”\n\nWhat is a Biological “Event”?\n\nWhy is it important to study these?\nHow is it distinct from an “Object”?\n\n\n\nSetting the bounds\n\nWhat kinds of signals are we looking to extract events from?\nWhat spatiotemporal scales are relevant?\nWhat types of microscopes/imaging assays are in the scope of this chapter?\n\nLimiting the scope\n\n\nBrief history/evolution of automated event/object detection in general\n\nOffer some background to current methods\n\nIncluding classical up to SVM\n\ne.g micropilot and limitations\nCase Study #1 : CellProfiler\nCase Study #2 : Micropilot\n\n\n\nThe need for new methods\n\nDeep learning based and ML approaches\n\nWhere the algorithm learns what is important\nWhat are the advantages of these methods?\n\nWhat has been done recently in the literature?\n\nWhat is required to label, train and implement these methods?\n\nSpecial considerations for event detection modesl\nSpecifics of event detection in contast the other ML tasks\n\n\n\nReal-time vs a posteriori inference\n\nChallenges, opportunities\nEvent detection as the first step in the microscopy workflow\n\nLimitations and notes of caution related to inference\n\n“Trusting the algorithms”\n\nConclusion",
    "crumbs": [
      "Image Acquisition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Adding AI to Your Hardware</span>"
    ]
  },
  {
    "objectID": "8-existing-tools.html",
    "href": "8-existing-tools.html",
    "title": "8  Finding and Using Existing Tools",
    "section": "",
    "text": "8.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 8 should discuss pre-existing tools that do not require programming knowledge. The chapter should start with a brief discussion of what to consider when searching for pre-trained models and software packages on sites (e.g., BioImage Model Zoo, Bioimage Informatics Index (BIII), image.sc). This should be followed by a discussion of a few specific tools (e.g., CellProfiler, Cellpose, ImageJ’s Weka Segmentation), highlighting what to look for in a tool, potential pitfalls, etc.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Finding and Using Existing Tools</span>"
    ]
  },
  {
    "objectID": "8-existing-tools.html#include-section-headers-as-appropriate",
    "href": "8-existing-tools.html#include-section-headers-as-appropriate",
    "title": "8  Finding and Using Existing Tools",
    "section": "",
    "text": "8.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Finding and Using Existing Tools</span>"
    ]
  },
  {
    "objectID": "8-existing-tools.html#bibliography-and-citations",
    "href": "8-existing-tools.html#bibliography-and-citations",
    "title": "8  Finding and Using Existing Tools",
    "section": "8.2 Bibliography and Citations",
    "text": "8.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Finding and Using Existing Tools</span>"
    ]
  },
  {
    "objectID": "8-existing-tools.html#adding-to-the-glossary",
    "href": "8-existing-tools.html#adding-to-the-glossary",
    "title": "8  Finding and Using Existing Tools",
    "section": "8.3 Adding to the Glossary",
    "text": "8.3 Adding to the Glossary\nWe are using the extension Quarto-glossary to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data to interpret your results. Clicking on the word will reveal its definition. The complete glossary for the book will be listed in the Glossary.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Finding and Using Existing Tools</span>"
    ]
  },
  {
    "objectID": "8-existing-tools.html#sec-equation",
    "href": "8-existing-tools.html#sec-equation",
    "title": "8  Finding and Using Existing Tools",
    "section": "8.4 Code and Equations",
    "text": "8.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 8.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 8.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{8.1}\\]\n\n8.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 8.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Finding and Using Existing Tools</span>"
    ]
  },
  {
    "objectID": "8-existing-tools.html#quarto-has-additional-features.",
    "href": "8-existing-tools.html#quarto-has-additional-features.",
    "title": "8  Finding and Using Existing Tools",
    "section": "8.5 Quarto has additional features.",
    "text": "8.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Finding and Using Existing Tools</span>"
    ]
  },
  {
    "objectID": "9-train-models.html",
    "href": "9-train-models.html",
    "title": "9  How to Train and Use Deep Learning Models in Microscopy",
    "section": "",
    "text": "9.1 Introduction",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>How to Train and Use Deep Learning Models in Microscopy</span>"
    ]
  },
  {
    "objectID": "9-train-models.html#sec-9.1",
    "href": "9-train-models.html#sec-9.1",
    "title": "9  How to Train and Use Deep Learning Models in Microscopy",
    "section": "",
    "text": "9.1.1 The challenge\nThe growing volume and complexity of image data necessitate increasingly advanced analytical tools. One example of challenging tasks is image segmentation, the process of identifying and delineating structures of interest within images. Segmentation can be particularly difficult and time-consuming when dealing with large, multidimensional datasets, such as 3D volumes or time-lapse sequences, where manual annotation becomes impractical. Machine learning (ML), especially deep learning (DL), can provide effective solutions to these challenges1.\nML algorithms learn patterns from data to perform tasks such as image classification and segmentation. Traditional ML methods, like random forest classifiers, depend on manually defined image features to classify pixels2–4. In contrast, DL algorithms can automatically discover and extract relevant features directly from image data using multilayer neural networks, which eliminates the need for manual feature selection. DL techniques are widely applied in complex image analysis tasks, including segmentation, object detection, feature extraction, denoising, and restoration5,6. Due to their ability to automatically learn hierarchical features, DL methods usually achieve greater accuracy and efficiency than traditional ML techniques7,8.\nSegmentation greatly benefits from ML and DL, as manual segmentation is extremely time-consuming and impractical for large datasets. This chapter offers practical guidance on preparing a segmentation project and emphasises effective DL applications to tackle these challenges. While we focus on segmentation as a case study, the principles, workflows, and considerations discussed here are broadly applicable to other image analysis tasks, such as classification or denoising. Readers interested in these areas can adapt the described approaches to their specific needs.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>How to Train and Use Deep Learning Models in Microscopy</span>"
    ]
  },
  {
    "objectID": "9-train-models.html#sec-9.2",
    "href": "9-train-models.html#sec-9.2",
    "title": "9  How to Train and Use Deep Learning Models in Microscopy",
    "section": "9.2 Preparing for your project",
    "text": "9.2 Preparing for your project\n\n9.2.1 Defining your task and success criteria\nEvery image analysis project should begin by clearly defining the scientific question you wish to answer, along with the criteria by which success will be measured. These foundational decisions will fundamentally shape your entire workflow. Careful planning of your objectives ensures that the chosen approach closely aligns with your scientific goals and will guide critical decisions about data annotation, model selection and performance evaluation.\nSince segmentation serves as the central example in this chapter, it is important to first understand the different types of segmentation tasks encountered in microscopy before discussing how deep learning methods can be applied. These tasks can typically be categorised into three main types (Figure 9.1). Each segmentation type presents distinct challenges and is suited to different biological questions:\nBinary segmentation: This is the simplest form of segmentation that separates the foreground from the background. For example, in a microscopy image, this involves distinguishing cell nuclei (foreground) from the rest of the image (background). This method is useful for detecting whether a structure is present or absent without distinguishing individual objects.\nInstance segmentation: This type of segmentation identifies and labels each object independently. For instance, each cell in an image obtains a unique label. This method is crucial for tracking individual cells over time or measuring specific characteristics of each cell separately.\nSemantic segmentation: This segmentation strategy involves labelling every pixel in an image according to its class, such as “nucleus,” “cytoplasm,” or “background.” Unlike instance segmentation, semantic segmentation does not differentiate between individual objects within the same class. This method is beneficial for analysing the spatial relationships and distribution of various cellular components.\n\n\n\n\n\n\nFigure 9.1: The three main types of segmentation in microscopy images. original: A raw grayscale fluorescence microscopy image showing cell nuclei stained with a nuclear marker. binary segmentation: Simplifies the image into two classes—foreground (white, nuclei) and background (black). instance segmentation: Assigns a unique label (shown in different colours) to each nucleus, facilitating individual object identification. semantic segmentation: Categorises each pixel into predefined classes—nucleus (purple), nucleus edge (yellow), and background (teal)—without distinguishing between individual objects.\n\n\n\nConsider whether your segmentation solution is meant for a specific experiment or needs to generalise across various imaging techniques, sample types, or experimental conditions. Additionally, evaluate the volume of data to analyse, the feasibility of manual analysis, and the resources available to create a tailored image analysis pipeline. Avoid overengineering a solution when a simple analysis could provide the answer you seek.\nAlongside task-specific considerations, it is equally important to clearly define the success criteria based on your objectives. For example, be prepared to answer the question, “What do I need to accomplish for my analysis to be sufficient?” – see Chapter 10 for more information. This is important because no analysis is ever 100% accurate. Establishing these criteria early streamlines both the development and evaluation processes, ensuring that your outcomes are scientifically meaningful and practically useful (see Chapter 10).\nWhile the following steps focus on segmentation, the underlying principles can be readily adapted to a wide range of DL tasks in microscopy.\n\n\n9.2.2 Evaluating alternatives: Is DL the right choice?\n\n\n\n\n\n\nFigure 9.2: Is DL the right choice for your segmentation project? This decision tree guides the selection of appropriate segmentation approaches based on data complexity and project needs. Begin by testing classical image processing methods, such as intensity-based thresholding, which are efficient and easy to apply for well-defined features. If these methods prove insufficient, consider using a pixel classifier, which provides a user-friendly and effective solution for smaller datasets. Only consider DL if you possess a large annotated dataset and previous methods have failed. In the absence of suitable data or methods, manual annotation may be necessary.\n\n\n\nChoosing the right computational method is essential for consistent and reproducible image analysis. For example in segmentation tasks, while DL can deliver exceptional segmentation performance, traditional methods and pixel classifiers still offer straightforward and efficient solutions for most tasks (Figure 9.2).\nTraditional image processing techniques—such as intensity-based thresholding, morphological operations, edge detection, and filtering—are ideal for objects with clear, distinguishable features. These methods are well-documented, easy to understand, and usually require minimal computing resources. Pixel classifiers, in particular, are user-friendly and can efficiently tackle many segmentation challenges with minimal manual annotation, making them highly effective for simpler analyses or smaller datasets.\nDL methods excel in complex scenarios where traditional approaches fail, especially when dealing with noisy or context-dependent data. When trained on large, annotated datasets, DL models can effectively generalise across diverse imaging conditions and sample types, rapidly processing significant volumes of images. However, in the absence of pre-trained models, DL methods rarely offer shortcuts for data analysis. DL methods generally take effort and time to implement.\nIf you are unsure which approach to use, we usually recommend first trying classical image processing methods and pixel classifiers (Figure 9.1). We typically initiate a DL project only if these methods fail to produce satisfactory results (see Section 9.3.3.2).",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>How to Train and Use Deep Learning Models in Microscopy</span>"
    ]
  },
  {
    "objectID": "9-train-models.html#sec-9.3",
    "href": "9-train-models.html#sec-9.3",
    "title": "9  How to Train and Use Deep Learning Models in Microscopy",
    "section": "9.3 Implementing a DL segmentation workflow",
    "text": "9.3 Implementing a DL segmentation workflow\nAlthough we use segmentation as our primary example, the workflow outlined in this section can be adapted to other deep learning tasks in microscopy and bioimage analysis.\n\n9.3.1 Overview of a typical DL segmentation workflow\nOnce you decide to implement a DL approach for segmentation, the workflow can be divided into a series of steps (Figure 9.3).\nThe process starts by clearly defining your task (in this example, segmentation) and selecting the right DL approach (Step 1). Next, evaluate whether any existing pre-trained models can be used directly on your data or adapted for use (Step 2). If additional training is required—either from scratch or through transfer learning—prepare an appropriate training dataset that reflects your segmentation problem (Step 3). Then, train your model using the prepared dataset (Step 4) and thoroughly evaluate its performance using validation or test data (Step 5). Based on the results, you may need to refine the model by adjusting hyperparameters, improving annotations, or expanding the dataset. Once the model performs satisfactorily, it can be used to segment new, unseen data (Step 6). We will now discuss each step in more detail.\n\n\n\n\n\n\nFigure 9.3: Conceptual workflow for training a DL segmentation model. The workflow begins with defining the segmentation task (Step 1), followed by searching for suitable pre-trained models (Step 2). If no such model exists, a training dataset must be prepared (Step 3), and the model is trained (Step 4). The trained model is then evaluated on validation or test data (Step 5). If it performs well, it can be applied to new data (Step 6); otherwise, the model is iteratively refined by returning to earlier steps. Feedback loops from evaluation to earlier stages help refine and improve the model accuracy.\n\n\n\n\n\n9.3.2 Selecting a suitable DL approach\nThe first step in choosing a DL approach for image segmentation is to clearly define your segmentation task, whether it’s binary, semantic, or instance segmentation (Figure 9.1), and to determine if you require 2D or 3D segmentation. Next, you should consider whether the model or tool you plan to use makes assumptions about the shapes or structures of the objects you want to segment. Understanding these assumptions will aid in selecting a model that fits your specific biological problem (see Section 9.2.1). Additionally, consider the amount of data that needs annotation for a particular DL approach (see Section 9.3.4.5). Finally, take into account your available computational resources (see Section 9.4.2). More complex models typically demand more GPU memory, longer training times, and additional storage, especially for 3D data or large datasets.\nFor example, StarDist9, a widely used tool for nuclei segmentation, assumes that objects are star-convex polygons: i.e., a shape for which any two points on its boundary can be connected by a single line that does not intersect the boundary. This assumption works well for round or oval shapes but makes StarDist less suitable for segmenting irregularly shaped or elongated structures. In contrast, Cellpose10 uses spatial vector flows to direct pixels toward object centres. This approach enables Cellpose to segment objects of various shapes and sizes, including irregular, elongated, or non-convex forms.\nChoosing the right DL strategy requires aligning your goal, object shape, data dimensionality, and computing capacity with the strengths and assumptions of the available DL architectures.\n\n\n9.3.3 Deciding whether to train a new model\n\n\n\n\n\n\nFigure 9.4: Decision workflow for selecting a DL model training approach. This flowchart outlines how to determine an appropriate training approach based on the availability and performance of pre-trained models.\n\n\n\n\n9.3.3.1 Leveraging pre-trained models\nThe increasing availability of already trained (pre-trained) DL models has greatly simplified image analysis. Many of these models can be directly applied to your data, removing the need to train your own model11,12. This reduces the technical barrier and saves time, making advanced analysis more accessible. However, it is essential to evaluate the quality of any pre-trained model before relying on its results (Figure 9.4). A model that performs well in one context may not be as effective on your specific data. Always conduct quality control by visually inspecting the outputs and assessing performance with quantitative metrics such as Intersection over Union (IoU) or F1-score, using a small, representative test set. This step is vital when model predictions are used in downstream analyses (see Section 9.3.7).\nAnother significant benefit of pre-trained models is their adaptability. Instead of starting from scratch, you can often fine-tune an existing model (see Section 9.3.6). This method entails retraining the model with a smaller, task-specific dataset, enabling it to adjust to your images while requiring far fewer annotations.\nSeveral excellent resources host pre-trained models suitable for microscopy. Researchers also increasingly share trained models alongside their datasets and publications, promoting open science. Platforms like Zenodo are commonly used for this purpose13,14, although deployment may require handling specific file formats or environments (see Chapter 8 for more information).\n\n\n9.3.3.2 When to train your model\nPre-trained models serve as an excellent starting point for various microscopy tasks. However, there are many scenarios where training a custom model becomes essential. Custom training enables the model to learn the specific characteristics of your dataset, experiment, or imaging modality, resulting in enhanced performance15–17. This is particularly crucial when your data differs significantly from the data used to train existing models. Thus, their performance should always be validated. If quality assessment metrics are poor or key features are not accurately segmented, consider training your own model.\nUltimately, always evaluate the model’s performance against your defined success criteria (see Section 9.3.7). Custom training may be the best path forward if the current model does not meet your needs.\n\n\n\n9.3.4 Preparing your dataset for training\nA well-designed training dataset is essential for developing successful DL models on tasks such as segmentation. The number of images and the quality of annotations needed vary based on factors such as task complexity and the architecture of the intended model.\n\n9.3.4.1 Types of model training\nFor segmentation, most DL models are trained using supervised learning, where each input image is paired with a manually annotated ground truth mask. In this context, all objects that need segmentation must be annotated in the training dataset. This approach enables the model to learn a direct mapping from raw images to segmentation outputs (Figure 9.7).\nHowever, alternative approaches can help reduce the need for extensive manual annotations:\n\nUnsupervised learning trains models without paired input and output data. Instead, the network identifies patterns or similarities in unlabelled images18.\n\nSelf-supervised learning involves designing tasks in which the model learns useful features directly from the input data without needing explicit labels19.\n\nWeakly supervised learning uses partial, noisy, or imprecise labels to guide training, which can significantly reduce annotation effort20,21.\n\n\n\n9.3.4.2 Creating Manual Annotations\nCreating accurate annotations manually is time-consuming, particularly for 3D datasets. Tools like Fiji22, Napari23, and QuPath24 are frequently employed for manual labelling. Typically, manual annotation involves drawing each object on the image and converting it into a mask or label.\n\n\n\n\n\n\nTipHere it is an example pipeline for manually annotating data using Fiji13\n\n\n\n\n\n\nOpen Fiji – activate the LOCI update site and restart Fiji.\nLOCI tools are required for exporting ROI maps. To enable them, go to Help &gt; Update &gt; Manage Update Sites, look for ‘LOCI’ and check the Active checkbox. Then, click on Apply and Close and Apply Changes, this update site ensures the necessary plugins are installed. Finally, restart Fiji.\nOpen your image you wish to annotate.\nUse File › Open to browse and load the microscopy image that you want to label manually. You can also drag and drop your image to Fiji.\nSelect the Oval or Freehand selection tool.\nThese tools, found in the Fiji toolbar, allow you to manually outline the structures of interest in your image.\nStart drawing around each object (yes, each one!).\nCarefully trace each cell or feature you want to annotate—precision is key to ensure useful training data for DL.\nAfter drawing each object, press “t” on your keyboard → the selection will be stored in the ROI manager.\nThis adds the drawn region to the ROI (Region of Interest) list, keeping track of all annotated objects in the image.\nRepeat until all objects are in the ROI manager.\nContinue drawing and pressing “t” until you have annotated every relevant object in the image.\nWhen finished, go to Plugins › LOCI › ROI Map.\nThis plugin converts all saved ROIs into a single labeled ROI map image, assigning unique values to each region.\nSave the generated ROI map with the same title as the original image in a separate folder.\nConsistent naming ensures each annotated map can be correctly matched with its corresponding raw image during training or analysis.\nAt the end, you will have one folder with the original images and another for the ROI maps.\nThis separation makes it easier to organise and use your data with image analysis or DL pipelines.\n\n\n\n\n\n\n9.3.4.3 Accelerating annotation with automatic initial segmentations\nCreating high-quality annotations often represents the most time-consuming aspect of training a DL model for segmentation. To alleviate this burden, you can start from automatically produced initial segmentations. For example, using simple thresholding methods such as Otsu’s thresholding to generate rough segmentations can decrease the total annotation time. Even more powerfully, pre-trained DL models such as those provided with StarDist9 and Cellpose10 can generate more accurate initial segmentations that users can manually refine. These annotations can then be used to retrain the model, establishing an iterative cycle that accelerates both labelling and model refinement.\nNew tools are also pushing the boundaries of interactive annotation. For example, Segment Anything for Microscopy (μSAM)15 facilitates automatic and user-guided segmentation and allows the model to be retrained on user-provided data. Similarly, Cellpose 2.016 features a human-in-the-loop workflow, allowing users to edit DL-generated segmentations. This hybrid approach enhances accuracy while significantly reducing the time and effort required for manual annotation.\n\n\n9.3.4.4 Expanding your dataset with augmentation and synthetic data\nWhen the number of training samples is limited, augmentation techniques can enhance dataset diversity to improve the model’s generalisation ability and performance on validation and testing25,26. Common augmentation strategies include image rotation, flipping, scaling, and contrast adjustment. However, it’s important to apply augmentation carefully, as excessive or unrealistic augmentation can confuse the model or cause it to learn patterns that do not exist in real data.\nIn the absence of sufficient real data, synthetic data generated through simulations or domain randomization can help pre-training a model27,28. These synthetic samples can expose the model to a broader range of scenarios early in training, before transitioning to fine-tuning with real, annotated data.\nIn summary, a successful segmentation pipeline relies on a careful balance between data quantity and annotation quality. Augmentation strategies can efficiently help to scale and balance training datasets.\n\n\n9.3.4.5 Choosing the dataset size: specific vs. general models\nIn supervised training, it is crucial that each image in the training set is accompanied by a corresponding label image (see Section 9.3.4.1). The number of image-label pairs required depends on the number of labels per image, the complexity of the model and the desired level of generalisability. Still, the key is having enough representative examples and corresponding annotations for the model to learn meaningful patterns.\nSmall and well-curated datasets consisting of tens of images may suffice for highly specific applications, such as segmenting cells or nuclei using a defined imaging modality17. In these scenarios, transfer learning can also be especially beneficial (see Section 9.3.6). Models designed to generalise across a wide range of conditions, tissue types, or imaging modalities typically require much larger and more diverse datasets (hundreds to thousands of annotated images)10. These datasets are essential for capturing the inherent variability in broader use cases.\n\n\n\n9.3.5 Training a segmentation model from scratch\nOnce you have annotated your training dataset, the next steps are to organise your data for training, initialise your model by selecting appropriate hyperparameters, and start the training process (Figure 9.7).\n\n9.3.5.1 Splitting your training data: training, validation, and test sets\nA crucial part of preparing your dataset is dividing it into three subsets: training, validation, and test sets. Each subset should contain the original microscopy images paired with their corresponding ground truth segmentations. A common strategy is to allocate 70–80% of the data for training, 10–15% for validation, and the remainder for testing. To ensure unbiased evaluation, ensure these subsets do not overlap in terms of fields of view, represent the variability of your entire dataset, and are randomly assigned to each set respectively.\nThe training set is used to train the model to recognise relevant features. To enhance generalisation, it must encompass a broad spectrum of scenarios and image conditions. Otherwise, the model risks overfitting—excelling with the training data but faltering with new images (Figure 9.6).\nThe validation set is used during training to provide feedback on the model’s performance with unseen data. This feedback, conveyed as validation loss, assists in detecting overfitting (Figure 9.6), guiding hyperparameter tuning (see Section 9.3.5.3), and informing training decisions. Although a separate validation set is ideal, many workflows create one in practice by reserving a portion (typically 10% to 30%) of the training data.\nThe test set, which serves a separate role, evaluates the model’s performance on entirely unseen data. Unlike the validation set, the test set is not utilised during training, ensuring an unbiased performance assessment. Test images should also include ground truth annotations to facilitate quantitative quality control. Reporting test set performance, using metrics such as accuracy, IoU, or F1-score, is crucial, especially when publishing or benchmarking your model29.\n\n\n9.3.5.2 Understanding the training process\nA DL model is composed of multiple layers (Figure 9.5). Each layer contains tens to hundreds of image processing operations (typically multiplications or convolutions), each controlled by multiple adjustable parameters (called weights). Altogether, a DL model may contain millions of adjustable weights. When an input image is processed by a DL model, it is sequentially processed by each layer until an output is generated. Segmentation tasks typically involve converting input images into labelled outputs. During training, the model weights are modified as the model learns how to perform a specific task.\n\n\n\n\n\n\nFigure 9.5: 2D U-Net architecture for image segmentation. It applies layers of convolutions, pooling, and upsampling to extract features and generate labelled segmentation masks. During training, model weights are iteratively adjusted based on the difference between predictions and ground truth labels, using a loss function and backpropagation.\n\n\n\nTraining begins with initialising these weights. When training from scratch, the initialisation is often random. However, when using a pre-trained model, the weights are already optimized based on previous training, providing the model with a significant head start (see Section 9.3.6).\nThe training process is iterative (Figure 9.7). Each cycle of training is called an epoch. During each epoch, the model typically learns from every image in the training set. Since datasets are often too large to fit into memory all at once, each epoch is divided into steps or iterations, with each step processing a smaller subset of the data known as a batch. The batch size determines how many samples are processed simultaneously.\nDuring each step, the model generates predictions for the current data batch. These predictions are compared to the ground truth labels using a loss function that calculates the similarity between the predictions and the ground truths. This score is called the training loss. The model utilises this feedback to adjust its weights through a process known as backpropagation, guided by an optimisation algorithm, to improve its accuracy in future iterations.\nAt the end of each epoch, the model assesses its performance on the validation set, which comprises data it has not encountered during training. This produces the validation loss, indicating how well the model generalises to new data.\nMonitoring both training and validation losses during training helps determine whether the model is learning effectively. A consistently decreasing validation loss indicates that the model is improving and generalising well (see Section 9.3.5.4).\n\n\n9.3.5.3 Choosing your model hyperparameters\nNow that you understand the training process, the next step is to configure the model’s hyperparameters, which are the settings that dictate how the model learns. While the model’s parameters (its weights) are updated during training, hyperparameters are established beforehand, defining the structure and behaviour of the training process. Below are some of the most common hyperparameters and their effects on training:\n\nBatch size: This refers to the number of images processed simultaneously in each training step. Smaller batch sizes are less demanding on memory and may enhance generalisation, although they can result in slower training. In contrast, larger batch sizes accelerate training but necessitate more GPU memory.\nEpochs: An epoch refers to a training cycle in which the model processes the entire training dataset. Increasing the number of epochs allows the model to learn more, but also raises the risk of overfitting. More is not always better; it is essential to monitor performance on the validation set.\nLearning rate: It determines the extent to which the model’s weights are adjusted during training. A high learning rate can result in quicker training but may overshoot the optimal solution. Conversely, a low learning rate provides more stable progress, although it may slow down convergence.\nOptimizer: An algorithm that updates weights to minimise the loss function. Common optimisers include SGD (stochastic gradient descent) and Adam (adaptive moment estimation), the latter being widely used for its adaptive learning rate and robust performance.\nLearning rate scheduler: Dynamically adjusts the learning rate during training, typically decreasing it after a specific number of epochs or when the validation loss plateaus. This approach helps balance rapid early learning with more refined convergence later on.\nPatch size: Instead of using full-resolution images, smaller patches are often utilised for training to reduce memory usage and enhance training speed. The patch size is determined by both available resources and the scale of the structures to be segmented.\nPatience (early stopping): This parameter defines the number of epochs to wait before halting training if the validation loss does not improve. It helps prevent wasting resources on overfitting and overtraining.\n\nGiven the many possible configurations, tuning hyperparameters is often essential—especially when applying a model to new data. Start with the recommended values from the model’s original publication, but you might need to conduct a hyperparameter search to optimize performance. This can range from a simple grid search to more advanced methods, such as Gaussian process-based Bayesian optimisation30 or genetic algorithms31.\n\n\n9.3.5.4 Monitoring training and validation Losses\nOnce your model begins training, it is helpful to evaluate its learning progress. The two key metrics for assessment are the training loss and the validation loss (Figure 9.6). Monitoring both throughout the training process offers insight into whether your model is improving and learning to generalise beyond the training data. The three main behaviours that you may encounter during training are:\n\n\n\n\n\n\nFigure 9.6: Monitoring training and validation losses during model training. The plot illustrates three typical learning behaviours: underfitting (both losses remain high and similar), good fitting (both losses decrease, with validation loss slightly higher), and overfitting (training loss continues to decrease while validation loss plateaus or increases), highlighting the importance of tracking these metrics to assess model performance and generalisation.\n\n\n\n\nUnderfitting: The model has been trained with insufficient data or for too few epochs, resulting in similar training and validation losses, which is far from optimal.\n\nGood fitting: Both training and validation losses decrease, with the validation loss slightly higher (worse) than the training loss, which is expected. This represents the ideal scenario.\n\nOverfitting: The model achieves an excellent training loss, but the validation loss does not improve and may in fact diverge. This may indicate overly similar training data or excessive training epochs, preventing the model from generalising to new data.\n\n\n\n\n9.3.6 Fine-Tuning Pre-existing Models\nInstead of training a model from scratch, fine-tuning an existing DL model is usually more efficient, especially when your data resembles the dataset used to train the original model. This approach utilises pre-trained weights and previously learned features, significantly decreasing the amount of required annotated data, training time, and computational resources.\n\n9.3.6.1 Applying Transfer Learning\nTransfer learning refers to the process of taking a pre-trained model and adapting it to a new but related task by providing task-specific training data, typically in the form of manually annotated image pairs (Figure 9.7). Transfer learning typically involves freezing part of the model (for instance, the initial layers or all layers except the last ones), so their weights are not updated during training. Only the unfrozen layers are updated when the model is trained on new data. Then, the model is trained on the new data, but only the layers that you have unfrozen will be updated. Since the base model already encodes many useful low-level features (e.g., edges, shapes, textures), this approach allows researchers to focus on refining the model for their specific biological structures or imaging modalities32,33.\nThis method is especially effective when:\n\nYou have limited training data available.\n\nYour imaging conditions closely match those of the pre-trained model.\n\nYou wish to quickly adapt a general model to a specific dataset.\n\n\n\n9.3.6.2 Conducting fine-tuning\nIn classic fine-tuning, all layers of the pre-trained model are retrained, with their weights initialised from the original training (Figure 9.7)15,16. Thus, you continue training the full model using the new data. This approach allows the model to adjust more comprehensively to new data while still preserving the advantages of pre-learned features.\nClassic fine-tuning is ideal when:\n\nYour dataset is moderately different from the original training data (e.g., the same biological structure but different staining or modality).\n\nYou expect that earlier layers may need to adapt, not just the final classifier or output layers. Early layers in deep networks typically learn to detect general features such as edges, textures, or simple shapes, while later layers capture more complex, task-specific patterns. If your new data differs in basic appearance or imaging modality, updating the early layers helps the model better extract relevant low-level features from your images.\n\nYou have enough annotated data to avoid overfitting during full model training. Although this method is more computationally demanding than transfer learning, where only a subset of layers are retrained, it often leads to better results on diverse datasets..\n\n\n\n9.3.6.3 Iterative training: keeping humans in the loop\nIterative fine-tuning is an interactive approach that combines model prediction with human annotation (see Section 9.3.4.3). The workflow typically starts with a pre-trained model predicting new images. A user then manually corrects or annotates these predictions, and the improved annotations update the model (Figure 9.7). This cycle continues, progressively enhancing the model’s accuracy with each iteration until it performs as expected16,34,35.\nThis method is particularly powerful when:\n\nAnnotated data is scarce or expensive to generate.\n\nYou work with rare structures, unusual imaging conditions, or new experimental systems.\n\nYou want to efficiently build a custom model using feedback from domain experts.\n\n\n\n\n\n\n\nFigure 9.7: Strategies for training DL models for image segmentation. A model can be trained from scratch using a large annotated dataset, fine-tuned from a pre-trained model with task-specific data, or refined through human-in-the-loop workflows where model predictions are manually corrected and fed back for retraining. These approaches balance performance, data availability, and annotation effort.\n\n\n\n\n\n\n9.3.7 Evaluating the performance of your model\n\n\n\n\n\n\nFigure 9.8: Workflow for evaluating DL model performance during training and on test data. Evaluating model performance is essential before deploying any DL model for image segmentation. This diagram outlines a two-stage process: assessment during training and on a separate test set. During training, validation and training losses (see Section 9.3.5.4) guide whether to continue training, stop, or expand the dataset. After training, performance is evaluated using a test set. High test metrics (e.g., IoU, F1-score) indicate readiness for deployment. Borderline or poor results suggest reviewing errors, refining training data, or trying a different model. This approach ensures model reliability and task-specific performance.\n\n\n\nWith the rapid increase in DL tools and pre-trained models, it has become easier to use DL for image segmentation, but harder to determine which model will work best for your data. Regardless of how promising a model appears, you must always evaluate its performance before trusting its results. Evaluation is not optional; it is a critical step to ensure that the model meets the requirements of your specific task29 (Figure 9.8).\nThere are two main ways to evaluate a model:\n\nQualitative evaluation entails visually inspecting the model’s predictions. This approach can help you quickly identify clear errors or failures. It is effective for a small number of images, but it becomes impractical for large datasets or for comparing similar-looking outputs across multiple models.\n\nQuantitative evaluation provides objective metrics for comparing models and tracking improvements. To achieve this, you need a small, labelled test set (typically 5 to 10 images with accurate ground truth segmentations). This test set must remain independent of your training and validation data to ensure an unbiased assessment.\n\nCommon metrics used in quantitative evaluation include:\n\nIntersection over Union (IoU), also known as the Jaccard Index, measures the overlap between the predicted segmentation and the ground truth.\n\nF1-score (Dice coefficient): This is especially valuable when the object of interest covers a small area in the image, as it balances precision and recall.\n\nTrue Positives (TP), False Positives (FP), and False Negatives (FN) are particularly important in semantic segmentation and can be used to calculate the IoU or F1 score.\n\nFor more information on these metrics, we recommend29 (also see Chapter 10 for more information).\nIf a model fails to produce reasonable results, even on simple examples, you can often reject it based solely on qualitative inspection. However, in these cases, quantitative metrics can still help you understand how and where the model fails.\nIf your evaluation metrics indicate weak performance, especially for certain structures or image types, you may need to fine-tune the model (see Section 9.3.6). Consistently strong scores across various test images suggest that a model could be dependable and ready for deployment. If no pre-trained model meets your expectations, the best course may be to train your model using your images (see Section 9.3.5).\nIn summary, never skip evaluation. Every model must be tested—both visually and quantitatively—to ensure it truly works for your data and provides results you can trust.\n\n\n9.3.8 Deploying your model on new data\nOnce a segmentation model has been trained and validated, it can be used on new, unseen images. This step typically involves feeding new images into the model to generate segmentation predictions. The deployment approach relies on the computational resources (see Section 9.4.2) as well as the size and complexity of your dataset (Figure 9.9).\n\n\n\n\n\n\nFigure 9.9: Decision workflow for model deployment strategy based on computational resources. The choice of deployment strategy depends on the availability of computational resources (see Section 9.4.2) and the sensitivity of the data . If high-performance computing resources are available locally, these should be used for deployment. In their absence, consider whether the data can be transferred to the cloud. If so, cloud-based resources offer an efficient solution. However, if data transfer is restricted—due to size or sensitivity—local deployment remains the only option, though it may require significantly more time.\n\n\n\n\n\n9.3.9 Troubleshooting Common Problems\nI found a tool or DL model online, but it does not work. What should I do?\n\n\n\n\n\n\nFigure 9.10: Common DL segmentation problems and troubleshooting tips.\n\n\n\nWhen should I train a model or segment manually?\nRefer to (Section 9.3.3.2) for more details, but generally, this decision depends on your dataset and the performance of existing pre-trained models (Figure 9.10). If you only need to segment a small number of images, manually segmenting them is often the quickest and simplest solution. However, if you are dealing with a large dataset, it may be more efficient to annotate a small subset and use it to train a deep-learning model that can automate the segmentation of the rest.\nI decided to train my DL model, but it is not performing correctly. What should I do?\nFirst, ensure that you have trained the model for a sufficient number of epochs—this depends on the size of your dataset and the architecture of the model. Check the training loss: if it has plateaued, your model may be fully trained. If it is still decreasing, continue training.\nIf training is completed but results are poor, examine your data. Is the model missing specific features? Are there types of cells or structures that it consistently fails to segment? If so, ensure those examples are well represented and correctly annotated in your training data. You may need to enhance or expand your annotations.\nIf performance is poor, you may need additional annotated data to help the model generalise more effectively (Figure 9.8). Consider the following questions:\n\nIs my dataset balanced? Does it include sufficient examples of each structure or class I want to segment?\n\nAm I training on one experimental batch while validating or testing on another?\n\nHow many images should I have to train my model?\nRefer to Section 9.2.1 for more details. There’s no one-size-fits-all answer—it depends on the complexity of your task, your model architecture, and the variability in your data. More complex tasks typically require more data. Larger images can also be broken into more patches, effectively increasing your dataset size. While few-shot models are being developed for small datasets, most established DL models require a substantial amount of data.\nPossible technical issues that you may encounter when training your DL model.\n\nThe model predicts the same class for all pixels or segments in every cell. Your dataset might be unbalanced, containing too many similar examples. Adding more diverse or underrepresented examples can help the model learn to differentiate between classes.\n\nOut-of-memory errors during training: Consider reducing the batch size or the image patch size. If that doesn’t resolve the issue, consider switching to a workstation or cloud service with greater computational capacity.\n\nThe model performs well on training data but poorly on new images, suggesting overfitting (Figure 9.6). Implement data augmentation and increase dataset diversity to help the model generalise better.\n\nInconsistent results across different computers: Differences in GPUs or environments can cause slight variations in outcomes. If the differences are significant, verify that all systems use consistent software versions and configurations. For further information on this topic, refer to Section 9.4.3.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>How to Train and Use Deep Learning Models in Microscopy</span>"
    ]
  },
  {
    "objectID": "9-train-models.html#sec-9.4",
    "href": "9-train-models.html#sec-9.4",
    "title": "9  How to Train and Use Deep Learning Models in Microscopy",
    "section": "9.4 Further considerations for DL segmentation",
    "text": "9.4 Further considerations for DL segmentation\n\n9.4.1 Choosing the Right Tools for DL\nSelecting the right tools to train and use DL models depends mainly on your level of programming experience and comfort with technical interfaces.\nIf you prefer not to write code or use command-line tools, opt for platforms that offer graphical user interfaces (GUIs) or interactive notebooks with pre-configured workflows. These tools let you perform powerful segmentation tasks using intuitive interfaces and simple widgets.\nGUI-based tools include, for instance (see Chapter 8 for more tools):\n\nCellpose GUI\n\nFiji with DeepImageJ and StarDist plugins\n\nNapari\n\nIlastik\n\nQuPath\n\nInteractive Jupyter notebooks provide a flexible balance between code and GUI. They enable you to execute code in manageable steps (cells) and immediately see the results. Tools like BiaPy, and DL4MicEverywhere36 leverage Jupyter notebooks, concealing complex code behind user-friendly interfaces. These platforms cater to users with little or no coding experience while still allowing advanced users to access and modify code as needed. DL4MicEverywhere, in particular, established a widely adopted framework for training DL models via notebooks, contributing to the standardisation and simplification of the workflow.\nIf you are comfortable with programming, you will have even more flexibility. Languages such as Python, MATLAB, Julia, Java, and Rust provide options for building and customizing DL workflows. Python stands out as the most beginner-friendly and widely supported choice, boasting a large ecosystem of libraries and community support. Popular Python libraries for DL include PyTorch, TensorFlow, Keras, and JAX.\nWhile coding can involve a steeper learning curve, it allows you to create customized pipelines, integrate various tools, and troubleshoot intricate workflows, unlocking the full potential of DL for microscopy segmentation.\n\n\n9.4.2 Managing Computational Resources\nWhen using DL for microscopy, an important consideration is the availability and capacity of your computational resources (Figure 9.9). High-performance DL models, particularly those used for 3D image data, can be very demanding regarding memory and processing power.\nWhen selecting or designing a DL model, evaluate your available infrastructure:\n\nGPU memory: Determines how large your model and batch size can be.\n\nTraining time: Influences your ability to iterate quickly; simpler models train faster.\n\nDataset size: Larger datasets benefit from more powerful hardware and longer training times.\n\nA practical strategy involves starting with lightweight models that demand fewer resources and scaling up to more complex architectures only if performance improvements become necessary. Tools like StarDist and Cellpose, for example, provide efficient options that function effectively with relatively modest hardware.\nAdditionally, consider whether to train and deploy your model locally or in the cloud (Figure 9.11). Local training is often more feasible if you already have access to a compatible workstation and want full control over data and execution. However, cloud-based services like Google Colab or AWS offer access to more powerful hardware, removing the need for local infrastructure—this is especially beneficial when working with large models or 3D datasets.\nThere are four typical combinations of training and prediction workflows:\n\nTraining and prediction locally is well suited for small to medium-sized datasets, especially when computational demands are moderate and data privacy is a priority. This approach also supports some user-friendly desktop applications, such as the Cellpose 2.016, which can be run locally without requiring cloud access or advanced technical setup.\nTraining locally, prediction in the cloud may be useful when models are trained in-house but need to be deployed at scale or integrated into cloud-based pipelines.\nTraining in the cloud, prediction locally enables researchers to take advantage of powerful cloud GPUs for model development, while keeping inference close to the data source (e.g., a microscope workstation or in case of sensitive data).\nTraining and prediction in the cloud is well suited for collaborative projects or large-scale deployments, where access to centralized, scalable infrastructure is critical.\n\nChoosing between these strategies depends on your data size, hardware access, choice of software, collaboration needs, and whether your workflow prioritizes flexibility, scalability, or control.\n\n\n\n\n\n\nFigure 9.11: Training and deployment strategies for DL models in microscopy. Depending on the available tools and infrastructure, models can be trained and deployed locally or in the cloud. Modified from17.\n\n\n\n\n\n9.4.3 Ensuring Reproducibility in DL\nWhen sharing how you trained a DL model, two key elements often come to mind: the dataset used and the code that runs the model. However, in practice, reproducibility extends beyond just data and code. In programming environments like Python, which rely heavily on external libraries, ensuring reproducibility also requires capturing the exact configuration of the environment in which the model was trained.\nDL models are sensitive to changes in library versions and dependencies. Even minor differences in the software stack can result in inconsistent outcomes or training failures. While sharing a list of dependencies (e.g., a requirements.txt or a Conda environment file) is a constructive step, differences in operating systems or local setups can still lead to issues.\nA robust and increasingly popular solution is containerisation. Containers package software, dependencies, and environment settings into a portable and self-contained unit. One of the most widely used containerization tools is Docker. A Docker container can be considered a lightweight, standalone virtual machine that includes everything needed to run code, such as the operating system, libraries, and runtime, ensuring applications run consistently across different machines.\nUsing containers ensures that your model training and inference processes remain consistent, no matter who executes them or where they are conducted. This greatly simplifies the ability of collaborators or reviewers to reproduce your results.\nFor researchers unfamiliar with software development, tools like DL4MicEverywhere36 and bia-binder37 simplify the use of containers by integrating them into user-friendly Jupyter notebook environments. These platforms enable researchers to benefit from the reproducibility of containers without needing to manage complex setups or command-line tools.\nReproducibility is crucial for establishing trust in computational results and facilitating long-term scientific collaboration. To ensure your DL workflows are reproducible, follow these best practices:\n\nPin every software version used in your workflow.\n\nDocument your environment setup thoroughly.\n\nProvide a containerised version of your training and inference pipeline when possible.\n\nTaking these steps will make it easier for others to reproduce your results, build on your work, and apply your models in different research settings.\n\nFor more information on best practices, consult29.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>How to Train and Use Deep Learning Models in Microscopy</span>"
    ]
  },
  {
    "objectID": "9-train-models.html#sec-9.5",
    "href": "9-train-models.html#sec-9.5",
    "title": "9  How to Train and Use Deep Learning Models in Microscopy",
    "section": "9.5 Summary & Outlook",
    "text": "9.5 Summary & Outlook\nSegmenting microscopy images remains a critical yet challenging task in bioimage analysis. In this chapter, we have used segmentation as a representative example to illustrate deep learning workflows and considerations. However, the strategies and best practices described here—such as data preparation, model selection, training, evaluation, and deployment—are relevant to a wide range of image analysis tasks, including classification, detection, and tracking. DL has undeniably transformed this field, offering robust solutions for segmenting complex and variable structures. However, as this chapter emphasizes, DL is not always the fastest or the best approach. Classical image processing techniques or pixel classifiers often provide faster, simpler, and highly effective alternatives in many scenarios.\nThe decision to use DL should be driven by the complexity of the task, the availability of annotated data, and the specific goals of the segmentation project. Successful DL implementations often require significant investments in data curation, annotation, and computational resources. Furthermore, training from scratch is frequently avoidable thanks to the growing ecosystem of pre-trained models and resources shared by the community.\nNotably, the landscape of DL segmentation is rapidly evolving. The emergence of foundation models, which are large, versatile networks pre-trained on vast and diverse datasets, promises to further lower the barriers to entry15. These models enable transfer learning, fine-tuning, and even zero-shot segmentation, where accurate predictions can be made on previously unseen data with minimal or no task-specific training. This shift opens exciting new avenues for researchers who previously lacked the resources or expertise to apply DL in their work.\nThe ongoing development and democratization of DL tools, along with enhancements in model generalisability, human-in-the-loop workflows, and reproducibility, are changing how microscopy data is analyzed. Still, the key to successful segmentation will always involve careful planning, quality control, and selecting the right tool for the task, whether it involves DL or not.\n\n\n\n\n\n1. Heinrich, L. et al. Whole-cell organelle segmentation in volume electron microscopy. Nature 599, 141–146 (2021).\n\n\n2. Arganda-Carreras, I. et al. Trainable Weka Segmentation: A machine learning tool for microscopy pixel classification. Bioinformatics 33, 2424–2426 (2017).\n\n\n3. Arzt, M. et al. LABKIT: Labeling and Segmentation Toolkit for Big Image Data. Frontiers in Computer Science 4, (2022).\n\n\n4. Berg, S. et al. Ilastik: Interactive machine learning for (bio)image analysis. Nature Methods 16, 1226–1232 (2019).\n\n\n5. Moen, E. et al. Deep learning for cellular image analysis. Nature Methods 16, 1233–1246 (2019).\n\n\n6. Pylvänäinen, J. W., Gómez-de-Mariscal, E., Henriques, R. & Jacquemet, G. Live-cell imaging in the deep learning era. Current Opinion in Cell Biology 85, 102271 (2023).\n\n\n7. Krizhevsky, A., Sutskever, I. & Hinton, G. E. ImageNet Classification with Deep Convolutional Neural Networks. in Advances in Neural Information Processing Systems vol. 25 (Curran Associates, Inc., 2012).\n\n\n8. Ronneberger, O., Fischer, P. & Brox, T. U-Net: Convolutional Networks for Biomedical Image Segmentation. in Medical Image Computing and Computer-Assisted Intervention – MICCAI 2015 (eds. Navab, N., Hornegger, J., Wells, W. M. & Frangi, A. F.) 234–241 (Springer International Publishing, Cham, 2015). doi:10.1007/978-3-319-24574-4_28.\n\n\n9. Schmidt, U., Weigert, M., Broaddus, C. & Myers, G. Cell Detection with Star-Convex Polygons. in Medical Image Computing and Computer Assisted Intervention – MICCAI 2018 (eds. Frangi, A. F., Schnabel, J. A., Davatzikos, C., Alberola-López, C. & Fichtinger, G.) 265–273 (Springer International Publishing, Cham, 2018). doi:10.1007/978-3-030-00934-2_30.\n\n\n10. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n11. Bejarano, L. et al. Interrogation of endothelial and mural cells in brain metastasis reveals key immune-regulatory mechanisms. Cancer Cell 42, 378–395.e10 (2024).\n\n\n12. Fisch, D. et al. Molecular definition of the endogenous Toll-like receptor signalling pathways. Nature 631, 635–644 (2024).\n\n\n13. Fazeli, E. et al. Automated cell tracking using StarDist and TrackMate. F1000Research 9, 1279 (2020).\n\n\n14. Follain, G. et al. Fast label-free live imaging reveals key roles of flow dynamics and CD44-HA interaction in cancer cell arrest on endothelial monolayers. (2024) doi:10.1101/2024.09.30.615654.\n\n\n15. Archit, A. et al. Segment Anything for Microscopy. Nature Methods 22, 579–591 (2025).\n\n\n16. Pachitariu, M. & Stringer, C. Cellpose 2.0: How to train your own model. Nature Methods 1–8 (2022) doi:10.1038/s41592-022-01663-4.\n\n\n17. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).\n\n\n18. Kochetov, B. et al. UNSEG: Unsupervised segmentation of cells and their nuclei in complex tissue samples. Communications Biology 7, 1–14 (2024).\n\n\n19. Liu, B. et al. Self-supervised learning reveals clinically relevant histomorphological patterns for therapeutic strategies in colon cancer. Nature Communications 16, 2328 (2025).\n\n\n20. Caicedo, J. C., McQuin, C., Goodman, A., Singh, S. & Carpenter, A. E. Weakly Supervised Learning of Single-Cell Feature Embeddings. in 2018 IEEE/CVF Conference on Computer Vision and Pattern Recognition 9309–9318 (2018). doi:10.1109/CVPR.2018.00970.\n\n\n21. Moshkov, N. et al. Learning representations for image-based profiling of perturbations. Nature Communications 15, 1594 (2024).\n\n\n22. Schindelin, J. et al. Fiji: An open-source platform for biological-image analysis. Nature Methods 9, 676–682 (2012).\n\n\n23. Ahlers, J. et al. Napari: A multi-dimensional image viewer for Python. (2023) doi:10.5281/zenodo.8115575.\n\n\n24. Bankhead, P. et al. QuPath: Open source software for digital pathology image analysis. Scientific Reports 7, 16878 (2017).\n\n\n25. Lecun, Y., Bottou, L., Bengio, Y. & Haffner, P. Gradient-based learning applied to document recognition. Proceedings of the IEEE 86, 2278–2324 (1998).\n\n\n26. Shorten, C. & Khoshgoftaar, T. M. A survey on Image Data Augmentation for Deep Learning. Journal of Big Data 6, 60 (2019).\n\n\n27. Lin, B. et al. A deep learned nanowire segmentation model using synthetic data augmentation. npj Computational Materials 8, 1–12 (2022).\n\n\n28. Rangel DaCosta, L., Sytwu, K., Groschner, C. K. & Scott, M. C. A robust synthetic data generation framework for machine learning in high-resolution transmission electron microscopy (HRTEM). npj Computational Materials 10, 1–11 (2024).\n\n\n29. Laine, R. F., Arganda-Carreras, I., Henriques, R. & Jacquemet, G. Avoiding a replication crisis in deep-learning-based bioimage analysis. Nature methods 18, 1136–1144 (2021).\n\n\n30. Ilievski, I., Akhtar, T., Feng, J. & Shoemaker, C. Efficient hyperparameter optimization for deep learning algorithms using deterministic RBF surrogates. Proceedings of the AAAI Conference on Artificial Intelligence 31, (2017).\n\n\n31. Alibrahim, H. & Ludwig, S. A. Hyperparameter optimization: Comparing genetic algorithm against grid search and bayesian optimization. in 2021 IEEE congress on evolutionary computation (CEC) 1551–1559 (2021). doi:10.1109/CEC45853.2021.9504761.\n\n\n32. Li, Y. & Shen, L. cC-GAN: A Robust Transfer-Learning Framework for HEp-2 Specimen Image Segmentation. IEEE Access 6, 14048–14058 (2018).\n\n\n33. Morid, M. A., Borjali, A. & Del Fiol, G. A scoping review of transfer learning research on medical image analysis using ImageNet. Computers in Biology and Medicine 128, 104115 (2021).\n\n\n34. Chen, J. et al. The Allen Cell and Structure Segmenter: A new open source toolkit for segmenting 3D intracellular structures in fluorescence microscopy images. (2020) doi:10.1101/491035.\n\n\n35. Conrad, R. & Narayan, K. Instance segmentation of mitochondria in electron microscopy images with a generalist deep learning model trained on a diverse dataset. Cell Systems 14, 58–71.e5 (2023).\n\n\n36. Hidalgo-Cenalmor, I. et al. DL4MicEverywhere: Deep learning for microscopy made flexible, shareable and reproducible. Nature Methods (2024) doi:10.1038/s41592-024-02295-6.\n\n\n37. Russell, C. T. et al. Bia-binder: A web-native cloud compute service for the bioimage analysis community. (2024) doi:10.48550/arXiv.2411.12662.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>How to Train and Use Deep Learning Models in Microscopy</span>"
    ]
  },
  {
    "objectID": "10-output-quality.html",
    "href": "10-output-quality.html",
    "title": "10  Output Quality",
    "section": "",
    "text": "10.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 10 addresses how to assess the quality of a model’s output, mentioning Metrics Reloaded. This chapter should address the question: how do I know my model is good enough? It should frame this discussion using the example of a segmentation model and discuss how tools can identify uncertain decisions from a model.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Output Quality</span>"
    ]
  },
  {
    "objectID": "10-output-quality.html#include-section-headers-as-appropriate",
    "href": "10-output-quality.html#include-section-headers-as-appropriate",
    "title": "10  Output Quality",
    "section": "",
    "text": "10.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Output Quality</span>"
    ]
  },
  {
    "objectID": "10-output-quality.html#bibliography-and-citations",
    "href": "10-output-quality.html#bibliography-and-citations",
    "title": "10  Output Quality",
    "section": "10.2 Bibliography and Citations",
    "text": "10.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Output Quality</span>"
    ]
  },
  {
    "objectID": "10-output-quality.html#adding-to-the-glossary",
    "href": "10-output-quality.html#adding-to-the-glossary",
    "title": "10  Output Quality",
    "section": "10.3 Adding to the Glossary",
    "text": "10.3 Adding to the Glossary\nWe are using R code to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data, validation data and false positives to interpret your results. Clicking on the word will reveal its definition by taking you to the entry on the Glossary page. Pressing back in your browser will return you to your previous place in the textbook.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Output Quality</span>"
    ]
  },
  {
    "objectID": "10-output-quality.html#sec-equation",
    "href": "10-output-quality.html#sec-equation",
    "title": "10  Output Quality",
    "section": "10.4 Code and Equations",
    "text": "10.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 10.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 10.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{10.1}\\]\n\n10.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 10.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Output Quality</span>"
    ]
  },
  {
    "objectID": "10-output-quality.html#quarto-has-additional-features.",
    "href": "10-output-quality.html#quarto-has-additional-features.",
    "title": "10  Output Quality",
    "section": "10.5 Quarto has additional features.",
    "text": "10.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "Image Analysis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Output Quality</span>"
    ]
  },
  {
    "objectID": "11-outlook.html",
    "href": "11-outlook.html",
    "title": "11  Outlook",
    "section": "",
    "text": "11.1 Include section headers as appropriate\nUnder your first header, include a brief introduction to your chapter.\nStarting prompt for this chapter: Chapter 11 concludes the book with a forward-looking assessment of AI in microscopy, focusing on how it can/will enable biological discovery. It should highlight a few motivational examples of discoveries that AI has already enabled and discuss opportunities to which the reader is primed to contribute after reading this book.\nUse markdown heading level two for section headers. You can use standard markdown formatting, for example emphasize the end of this sentence.\nThis is a new paragraph with more text. Your paragraphs can cross reference other items, such as Figure 11.1. Use fig to reference figures, and eq to reference equations, such as Equation 11.1.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Outlook</span>"
    ]
  },
  {
    "objectID": "11-outlook.html#include-section-headers-as-appropriate",
    "href": "11-outlook.html#include-section-headers-as-appropriate",
    "title": "11  Outlook",
    "section": "",
    "text": "11.1.1 Sub-subsection headers are also available\nTo make your sections cross reference-able throughout the book, include a section reference, as shown in the header for Section 11.4.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Outlook</span>"
    ]
  },
  {
    "objectID": "11-outlook.html#bibliography-and-citations",
    "href": "11-outlook.html#bibliography-and-citations",
    "title": "11  Outlook",
    "section": "11.2 Bibliography and Citations",
    "text": "11.2 Bibliography and Citations\nTo cite a research article, add it to references.bib and then refer to the citation key. For example, reference1 refers to CellPose and reference2 refers to ZeroCostDL4Mic.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Outlook</span>"
    ]
  },
  {
    "objectID": "11-outlook.html#adding-to-the-glossary",
    "href": "11-outlook.html#adding-to-the-glossary",
    "title": "11  Outlook",
    "section": "11.3 Adding to the Glossary",
    "text": "11.3 Adding to the Glossary\nWe are using R code to create a glossary for this book. To add a definition, edit the glossary.yml file. To reference the glossary, enclose the word as in these examples: LLMs suffer from hallucinations. It is important to understand the underlying training data, validation data and false positives to interpret your results. Clicking on the word will reveal its definition by taking you to the entry on the Glossary page. Pressing back in your browser will return you to your previous place in the textbook.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Outlook</span>"
    ]
  },
  {
    "objectID": "11-outlook.html#sec-equation",
    "href": "11-outlook.html#sec-equation",
    "title": "11  Outlook",
    "section": "11.4 Code and Equations",
    "text": "11.4 Code and Equations\nThis is an example of including a python snippet that generates a figure\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 11.1: Simple Plot\n\n\n\n\n\nIn some cases, you may want to include a code-block that is not executed when the book is compiled. Use the eval: false option for this.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\nFigures can also be generated that do not show the code by using the option for code-fold: true.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 11.2: A spiral on a polar axis\n\n\n\n\n\nHere is an example equation.\n\\[\ns = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\overline{x})^2}\n\\tag{11.1}\\]\n\n11.4.1 Embedding Figures\nYou can also embed figures from other notebooks in the repo as shown in the following embed example.\n\n\n\n\n\n\n\n\n\nFigure 11.3: Polar plot of circles of random areas at random coords\n\n\n\n\n\n\nWhen embedding notebooks, please store the .ipynb file in the notebook directory. Include the chapter in the name of your file. For example, chapter4_example_u-net.ipynb. This is how we will handle chapter- or example-specific environments. We will host notebooks on Google Colab so that any required packages for the code–but not for rendering the book at large–will be installed there. That way, we will not need to handle a global environment across the book.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Outlook</span>"
    ]
  },
  {
    "objectID": "11-outlook.html#quarto-has-additional-features.",
    "href": "11-outlook.html#quarto-has-additional-features.",
    "title": "11  Outlook",
    "section": "11.5 Quarto has additional features.",
    "text": "11.5 Quarto has additional features.\nYou can learn more about markdown options and additional Quarto features in the Quarto documentation. One example that you might find interesting is the option to include callouts in your text. These callouts can be used to highlight potential pitfalls or provide additional optional exercises that the reader might find helpful. Below are examples of the types of callouts available in Quarto.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, tip, warning, caution, and important. They can default to open (like this example) or collapsed (example below).\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nThese could be good for extra material or exercises.\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThere are caveats when applying these tools. Expand the code below to learn more.\n\n\nCode\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful to avoid hallucinations.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis is key information.\n\n\n\n\n\n\n1. Stringer, C., Wang, T., Michaelos, M. & Pachitariu, M. Cellpose: A generalist algorithm for cellular segmentation. Nature Methods 18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep learning for microscopy with ZeroCostDL4Mic. Nature Communications 12, 2276 (2021).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Outlook</span>"
    ]
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Backpropagation\nThe method used by neural networks to learn from its predictions. Once the prediction is done, it is compared with the ground truth through a training loss and the value of the comparison is used backwards to sequentially update the weights in the neural network, reward it when making a good prediction and punish it when making a bad prediction.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#batch",
    "href": "glossary.html#batch",
    "title": "Glossary",
    "section": "Batch",
    "text": "Batch\nA small group of data that is processed together at the same time. For example, when training a machine learning model, a batch is a group of data that is given to the model for learning. Batches are commonly used to make the processes more efficient.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#bayesian-optimization",
    "href": "glossary.html#bayesian-optimization",
    "title": "Glossary",
    "section": "Bayesian Optimization",
    "text": "Bayesian Optimization\nA strategy that allows the optimization of black-box functions such as deep neural networks. It creates a surrogate model, which is a probabilistic representation of the objective function, using only a few example points.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#binary-segmentation",
    "href": "glossary.html#binary-segmentation",
    "title": "Glossary",
    "section": "Binary Segmentation",
    "text": "Binary Segmentation\nA type of image segmentation where each pixel is classified into one of two categories—typically “foreground” (e.g., cell) or “background.” The output is a binary mask distinguishing objects (set to a value of 1) from their background (0).",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#data-augmentation",
    "href": "glossary.html#data-augmentation",
    "title": "Glossary",
    "section": "Data Augmentation",
    "text": "Data Augmentation\nA strategy to artificially increase the diversity of a dataset prior to training by applying transformations such as rotation, flipping, or brightness adjustment. It helps improve model robustness and generalisation.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#domain-randomization",
    "href": "glossary.html#domain-randomization",
    "title": "Glossary",
    "section": "Domain Randomization",
    "text": "Domain Randomization\nUsing simulations or synthetic training data, domain randomization applies random and exaggerated variations to background, lighting, shapes, or textures in the synthetic dataset. This strategy helps the model learn domain-invariant features and is usually used for pretraining a neural network or to enable simulation-to-real transfer.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#epoch",
    "href": "glossary.html#epoch",
    "title": "Glossary",
    "section": "Epoch",
    "text": "Epoch\nOne complete pass through the entire training dataset during the training process.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#f1-score",
    "href": "glossary.html#f1-score",
    "title": "Glossary",
    "section": "F1 Score",
    "text": "F1 Score\nA classification metric that gives the harmonic mean of precision (proportion of correct true positive predictions across all predicted positive cases) and recall (proportion of true positive predictions against the total positive cases). The harmonic mean is a method to balance both metrics equally. This metric was originally designed for binary classification but can be adapted to multiclass classification by calculating the F1 score per class.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#false-negatives",
    "href": "glossary.html#false-negatives",
    "title": "Glossary",
    "section": "False Negatives",
    "text": "False Negatives\nIn a scenario where you have two classes “positive” and “negative”, you try to predict cases as one of those classes. False negatives are the cases that you incorrectly predicted as negative and were really positive.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#false-positives",
    "href": "glossary.html#false-positives",
    "title": "Glossary",
    "section": "False Positives",
    "text": "False Positives\nIn a scenario where you have two classes “positive” and “negative”, you try to predict cases as one of those classes. False positives are the cases that you incorrectly predicted as positive and were really negative.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#gaussian-process",
    "href": "glossary.html#gaussian-process",
    "title": "Glossary",
    "section": "Gaussian Process",
    "text": "Gaussian Process\nA common surrogate model for optimization strategies such as Bayesian Optimization. Gaussian Processes are non-parametric a case that models a conditional probability function. In the hyperparameter search scenario, the Gaussian Process models the probability of getting an objective function value based on some hyperparameters.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#genetic-algorithms",
    "href": "glossary.html#genetic-algorithms",
    "title": "Glossary",
    "section": "Genetic Algorithms",
    "text": "Genetic Algorithms\nAn optimisation method inspired by the principles of natural selection and genetics. It starts with a population of solutions. These solutions are combined through a process called crossover to produce new solutions (offspring). During this process, random changes or mutations may occur to introduce diversity. After crossover and mutation, a selection step chooses the best solutions from both the parent and offspring populations to form the next generation. This cycle repeats for a set number of generations or until a predefined goal or stopping criterion is met.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#hallucinations",
    "href": "glossary.html#hallucinations",
    "title": "Glossary",
    "section": "Hallucinations",
    "text": "Hallucinations\nOutputs from a model that do not have a basis in the input data and may contain false or misleading information.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#hyperparameters",
    "href": "glossary.html#hyperparameters",
    "title": "Glossary",
    "section": "Hyperparameters",
    "text": "Hyperparameters\nThe options you choose when training a machine learning model that affect the training process or the architecture of the model (e.g., learning rate, batch size, number of layers, training loss, etc.) are called hyperparameters. This term is used to differentiate them from the parameters (also known as weights) of the machine learning model.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#image-classification",
    "href": "glossary.html#image-classification",
    "title": "Glossary",
    "section": "Image Classification",
    "text": "Image Classification\nA computer vision task where each image is associated with one class and the goal of this task is to correctly predict that class.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#inferences",
    "href": "glossary.html#inferences",
    "title": "Glossary",
    "section": "Inferences",
    "text": "Inferences\nTemporary definition.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#instance-segmentation",
    "href": "glossary.html#instance-segmentation",
    "title": "Glossary",
    "section": "Instance Segmentation",
    "text": "Instance Segmentation\nA segmentation task that not only separates objects from the background but also distinguishes between individual objects of the same type (e.g., separating touching cells one by one).",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#iou",
    "href": "glossary.html#iou",
    "title": "Glossary",
    "section": "IoU",
    "text": "IoU\n“Intersection over Union”. A segmentation metric that calculates the difference between the area of overlap between two segmentation masks divided by the area of union.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#manual-annotation",
    "href": "glossary.html#manual-annotation",
    "title": "Glossary",
    "section": "Manual Annotation",
    "text": "Manual Annotation\nThe process of manually labeling specific structures or objects in an image using drawing tools. Typically done in software like Fiji or Napari, this step is essential for creating ground truth data to train or evaluate machine learning models.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#object-detection",
    "href": "glossary.html#object-detection",
    "title": "Glossary",
    "section": "Object Detection",
    "text": "Object Detection\nA computer vision task that identifies and locates individual objects within an image, typically by drawing bounding boxes around them. It provides both the category (what) and position (where) of each object.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#pixel-classifiers",
    "href": "glossary.html#pixel-classifiers",
    "title": "Glossary",
    "section": "Pixel Classifiers",
    "text": "Pixel Classifiers\nMachine learning models that classify each pixel in an image based on features such as intensity, texture, or local neighborhood. Commonly used in traditional workflows for segmentation or classification tasks.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#semantic-segmentation",
    "href": "glossary.html#semantic-segmentation",
    "title": "Glossary",
    "section": "Semantic Segmentation",
    "text": "Semantic Segmentation\nA form of segmentation where each pixel in an image is assigned to a class (e.g., nucleus, cytoplasm, background), but it does not distinguish between separate instances of the same class.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#star-convex-polygon",
    "href": "glossary.html#star-convex-polygon",
    "title": "Glossary",
    "section": "Star-convex Polygon",
    "text": "Star-convex Polygon\nA geometric shape used in segmentation algorithms like StarDist. Imagine drawing straight lines (rays) from the centre of an object out toward its edges—if you can see the edge from the centre in all directions, the object is considered star-convex. This method works well for blob-like structures such as nuclei, because their general shape can be captured by measuring how far each ray travels from the centre to the boundary.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#test-data",
    "href": "glossary.html#test-data",
    "title": "Glossary",
    "section": "Test Data",
    "text": "Test Data\nTemporary definition.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#training-data",
    "href": "glossary.html#training-data",
    "title": "Glossary",
    "section": "Training Data",
    "text": "Training Data\nData used to train an algorithm to make predictions.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#transfer-learning",
    "href": "glossary.html#transfer-learning",
    "title": "Glossary",
    "section": "Transfer Learning",
    "text": "Transfer Learning\nA deep learning technique where part of a pretrained neural network (usually the initial layers, responsible for feature extraction) is frozen and reused in a new model. These frozen layers, with the knowledge from a previous dataset, are combined with untrained layers tailored for a specific bioimaging task. During training, only the new layers will be updated, allowing the model to adapt to the new task with limited data.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#true-negatives",
    "href": "glossary.html#true-negatives",
    "title": "Glossary",
    "section": "True Negatives",
    "text": "True Negatives\nIn a scenario where you have two classes “positive” and “negative”, you try to predict cases as one of those classes. True positives are the cases that you predicted as negative and were really negative.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#true-positives",
    "href": "glossary.html#true-positives",
    "title": "Glossary",
    "section": "True Positives",
    "text": "True Positives\nIn a scenario where you have two classes “positive” and “negative”, you try to predict cases as one of those classes. True positives are the cases that you predicted as positive and were really positive.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#validation-data",
    "href": "glossary.html#validation-data",
    "title": "Glossary",
    "section": "Validation Data",
    "text": "Validation Data\nTemporary definition.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "glossary.html#virtual-machine",
    "href": "glossary.html#virtual-machine",
    "title": "Glossary",
    "section": "Virtual Machine",
    "text": "Virtual Machine\nOn a physical computer, you install an operating system (e.g., Windows or Ubuntu) that you interact with. A virtual machine is a program that simulates a complete computer with its own operating system. This lets you run a “computer inside your computer” (e.g., using Linux inside Windows or the other way around). As this simulated computer is separate from your physical one, it adds an extra layer of security, because unless the user specifically allows it, the virtual machine cannot access or connect to your real computer.",
    "crumbs": [
      "Glossary"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "1. Stringer, C., Wang, T., Michaelos, M. &\nPachitariu, M. Cellpose: A generalist\nalgorithm for cellular segmentation. Nature Methods\n18, 100–106 (2021).\n\n\n2. Chamier, L. von et al. Democratising deep\nlearning for microscopy with ZeroCostDL4Mic. Nature\nCommunications 12, 2276 (2021).\n\n\n3. Arganda-Carreras, I. et al. Trainable\nWeka Segmentation: A machine learning tool for\nmicroscopy pixel classification. Bioinformatics\n33, 2424–2426 (2017).\n\n\n4. Berg, S. et al. Ilastik: Interactive\nmachine learning for (bio)image analysis. Nature Methods\n16, 1226–1232 (2019).\n\n\n5. Pachitariu, M. & Stringer, C. Cellpose 2.0:\nHow to train your own model. Nature Methods 1–8 (2022) doi:10.1038/s41592-022-01663-4.\n\n\n6. Schmidt, U., Weigert, M., Broaddus, C. &\nMyers, G. Cell Detection with\nStar-Convex Polygons. in\nMedical Image Computing and\nComputer Assisted Intervention –\nMICCAI 2018 (eds. Frangi, A. F., Schnabel, J. A.,\nDavatzikos, C., Alberola-López, C. & Fichtinger, G.) 265–273\n(Springer International Publishing, Cham, 2018). doi:10.1007/978-3-030-00934-2_30.\n\n\n7. Fazeli, E. et al. Automated cell\ntracking using StarDist and TrackMate.\nF1000Research 9, 1279 (2020).\n\n\n8. Schindelin, J. et al. Fiji: An open-source platform\nfor biological-image analysis. Nature Methods\n9, 676–682 (2012).\n\n\n9. Krizhevsky, A., Sutskever, I. & Hinton, G.\nE. ImageNet\nClassification with Deep\nConvolutional Neural\nNetworks. in Advances in Neural\nInformation Processing\nSystems vol. 25 (Curran Associates, Inc., 2012).\n\n\n10. Ahlers, J. et al. Napari: A\nmulti-dimensional image viewer for Python. (2023) doi:10.5281/zenodo.8115575.\n\n\n11. Arzt, M. et al. LABKIT:\nLabeling and Segmentation Toolkit\nfor Big Image Data.\nFrontiers in Computer Science 4, (2022).\n\n\n12. Russell, C. T. et al. Bia-binder:\nA web-native cloud compute service for the bioimage\nanalysis community. (2024) doi:10.48550/arXiv.2411.12662.\n\n\n13. Follain, G. et al. Fast label-free\nlive imaging reveals key roles of flow dynamics and\nCD44-HA interaction in cancer cell arrest on\nendothelial monolayers. (2024) doi:10.1101/2024.09.30.615654.\n\n\n14. Hidalgo-Cenalmor, I. et al.\nDL4MicEverywhere: Deep learning for microscopy made\nflexible, shareable and reproducible. Nature Methods (2024)\ndoi:10.1038/s41592-024-02295-6.\n\n\n15. Ronneberger, O., Fischer, P. & Brox, T.\nU-Net: Convolutional Networks for\nBiomedical Image Segmentation. in\nMedical Image Computing and\nComputer-Assisted Intervention –\nMICCAI 2015 (eds. Navab, N., Hornegger, J., Wells, W.\nM. & Frangi, A. F.) 234–241 (Springer International Publishing,\nCham, 2015). doi:10.1007/978-3-319-24574-4_28.\n\n\n16. Moen, E. et al. Deep learning for\ncellular image analysis. Nature Methods\n16, 1233–1246 (2019).\n\n\n17. Pylvänäinen, J. W., Gómez-de-Mariscal, E.,\nHenriques, R. & Jacquemet, G. Live-cell imaging in\nthe deep learning era. Current Opinion in Cell Biology\n85, 102271 (2023).\n\n\n18. Bankhead, P. et al. QuPath:\nOpen source software for digital pathology image\nanalysis. Scientific Reports 7, 16878\n(2017).\n\n\n19. Laine, R. F., Arganda-Carreras, I., Henriques,\nR. & Jacquemet, G. Avoiding a replication\ncrisis in deep-learning-based bioimage analysis. Nature\nmethods 18, 1136–1144 (2021).\n\n\n20. Heinrich, L. et al. Whole-cell organelle\nsegmentation in volume electron microscopy. Nature\n599, 141–146 (2021).\n\n\n21. Liu, B. et al. Self-supervised\nlearning reveals clinically relevant histomorphological patterns for\ntherapeutic strategies in colon cancer. Nature\nCommunications 16, 2328 (2025).\n\n\n22. Moshkov, N. et al. Learning\nrepresentations for image-based profiling of perturbations.\nNature Communications 15, 1594 (2024).\n\n\n23. Caicedo, J. C., McQuin, C., Goodman, A., Singh,\nS. & Carpenter, A. E. Weakly Supervised\nLearning of Single-Cell\nFeature Embeddings. in 2018\nIEEE/CVF Conference on\nComputer Vision and Pattern\nRecognition 9309–9318 (2018). doi:10.1109/CVPR.2018.00970.\n\n\n24. Archit, A. et al. Segment\nAnything for Microscopy. Nature\nMethods 22, 579–591 (2025).\n\n\n25. Li,\nY. & Shen, L. cC-GAN: A\nRobust Transfer-Learning\nFramework for HEp-2 Specimen\nImage Segmentation. IEEE Access\n6, 14048–14058 (2018).\n\n\n26. Morid, M. A., Borjali, A. & Del Fiol, G. A scoping review\nof transfer learning research on medical image analysis using\nImageNet. Computers in Biology and Medicine\n128, 104115 (2021).\n\n\n27. Kochetov, B. et al. UNSEG:\nUnsupervised segmentation of cells and their nuclei in complex tissue\nsamples. Communications Biology 7, 1–14\n(2024).\n\n\n28. Chen, J. et al. The Allen\nCell and Structure Segmenter: A\nnew open source toolkit for segmenting 3D intracellular\nstructures in fluorescence microscopy images. (2020) doi:10.1101/491035.\n\n\n29. Conrad, R. & Narayan, K. Instance segmentation\nof mitochondria in electron microscopy images with a generalist deep\nlearning model trained on a diverse dataset. Cell Systems\n14, 58–71.e5 (2023).\n\n\n30. Fisch, D. et al. Molecular definition\nof the endogenous Toll-like receptor signalling\npathways. Nature 631, 635–644\n(2024).\n\n\n31. Bejarano, L. et al. Interrogation of\nendothelial and mural cells in brain metastasis reveals key\nimmune-regulatory mechanisms. Cancer Cell\n42, 378–395.e10 (2024).\n\n\n32. Rangel DaCosta, L., Sytwu, K., Groschner, C. K.\n& Scott, M. C. A robust synthetic\ndata generation framework for machine learning in high-resolution\ntransmission electron microscopy (HRTEM). npj\nComputational Materials 10, 1–11 (2024).\n\n\n33. Lin, B. et al. A deep learned\nnanowire segmentation model using synthetic data augmentation.\nnpj Computational Materials 8, 1–12\n(2022).\n\n\n34. Shorten, C. & Khoshgoftaar, T. M. A survey on\nImage Data Augmentation for\nDeep Learning. Journal of Big\nData 6, 60 (2019).\n\n\n35. Lecun, Y., Bottou, L., Bengio, Y. &\nHaffner, P. Gradient-based\nlearning applied to document recognition. Proceedings of the\nIEEE 86, 2278–2324 (1998).\n\n\n36. Alibrahim, H. & Ludwig, S. A.\nHyperparameter optimization: Comparing genetic algorithm against grid\nsearch and bayesian optimization. in 2021 IEEE congress on\nevolutionary computation (CEC) 1551–1559 (2021). doi:10.1109/CEC45853.2021.9504761.\n\n\n37. Ilievski, I., Akhtar, T., Feng, J. &\nShoemaker, C. Efficient hyperparameter\noptimization for deep learning algorithms using deterministic RBF\nsurrogates. Proceedings of the AAAI Conference on Artificial\nIntelligence 31, (2017).",
    "crumbs": [
      "References"
    ]
  }
]